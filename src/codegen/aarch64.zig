const std = @import("std");
const mem = std.mem;

const mir = @import("mir.zig");
const MIRModule = mir.MIRModule;
const MIRFunction = mir.MIRFunction;
const MInst = mir.MInst;
const VReg = mir.VReg;
const Width = mir.Width;
const BinOp = mir.BinOp;
const GlobalVars = mir.GlobalVars;
const GlobalIndex = mir.GlobalIndex;

const Os = @import("codegen.zig").Os;
const CallingConvention = @import("../parser/ast.zig").CallingConvention;

/// Physical register (x0-x15).
pub const PReg = u4;

/// Lower MIR module to ARM64 assembly.
pub fn lower(allocator: mem.Allocator, module: *const MIRModule, os: Os) ![]const u8 {
    var emitter = try Emitter.init(allocator, os);
    defer emitter.deinit();

    // header
    try emitter.comment("Generated by the Honey compiler");
    try emitter.newline();

    // emit data section for globals
    if (module.globals.count() > 0) {
        try emitter.directive(".data");
        try emitter.directive(".align 3"); // 8-byte alignment

        for (0..module.globals.count()) |i| {
            const idx: GlobalIndex = @intCast(i);
            const name = module.globals.getName(idx);
            const width = module.globals.getWidth(idx);
            const init_value = module.globals.getInitValue(idx);

            try emitter.globalData(name, width, init_value orelse 0);
        }
        try emitter.newline();
    }

    // text section
    try emitter.directive(".text");
    try emitter.directive(".align 2");
    try emitter.newline();

    // lower each function
    for (module.functions.items) |*func| {
        try lowerFunction(&emitter, func, &module.globals);
    }

    return try allocator.dupe(u8, emitter.getOutput());
}

fn lowerFunction(emitter: *Emitter, func: *const MIRFunction, globals: *const GlobalVars) !void {
    switch (func.call_conv) {
        .c => try lowerFunctionC(emitter, func, globals),
        .honey => try lowerFunctionHoney(emitter, func, globals),
        else => try lowerFunctionHoney(emitter, func, globals), // fallback for unimplemented conventions
    }
}

/// Track frame size for epilogue stack restoration.
const FunctionState = struct {
    frame_size: u16 = 0,
};

/// Lower function with C calling convention (AAPCS64).
/// - Underscore prefix on Darwin
/// - Full prologue/epilogue for stack frame
fn lowerFunctionC(emitter: *Emitter, func: *const MIRFunction, globals: *const GlobalVars) !void {
    var label_buf: [128]u8 = undefined;
    const label = if (emitter.os == .darwin)
        std.fmt.bufPrint(&label_buf, "_{s}", .{func.name}) catch unreachable
    else
        func.name;

    try emitter.global(label);
    try emitter.label(label);

    var reg_map = RegMap{};
    var func_state = FunctionState{ .frame_size = func.frame_size };
    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &reg_map, globals, &func_state);
    }

    try emitter.newline();
}

/// Lower function with Honey's native calling convention.
/// - No underscore prefix
/// - Could optimize prologue/epilogue for leaf functions in the future
fn lowerFunctionHoney(emitter: *Emitter, func: *const MIRFunction, globals: *const GlobalVars) !void {
    try emitter.global(func.name);
    try emitter.label(func.name);

    var reg_map = RegMap{};
    var func_state = FunctionState{ .frame_size = func.frame_size };
    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &reg_map, globals, &func_state);
    }

    try emitter.newline();
}

fn lowerInst(emitter: *Emitter, inst: MInst, reg_map: *RegMap, globals: *const GlobalVars, func_state: *const FunctionState) !void {
    switch (inst) {
        .mov_imm => |op| {
            const preg = reg_map.allocFor(op.dst);
            switch (op.width) {
                .w32 => try emitter.movImm32(preg, @truncate(@as(i64, op.value))),
                .w64 => try emitter.movImm64(preg, op.value),
            }
        },

        .mov_reg => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            const src_preg = reg_map.get(op.src);
            switch (op.width) {
                .w32 => try emitter.movReg32(dst_preg, src_preg),
                .w64 => try emitter.movReg64(dst_preg, src_preg),
            }
        },

        .binop => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            const lhs_preg = reg_map.get(op.lhs);
            const rhs_preg = reg_map.get(op.rhs);

            switch (op.op) {
                .add => switch (op.width) {
                    .w32 => try emitter.binop32("add", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("add", dst_preg, lhs_preg, rhs_preg),
                },
                .sub => switch (op.width) {
                    .w32 => try emitter.binop32("sub", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("sub", dst_preg, lhs_preg, rhs_preg),
                },
                .mul => switch (op.width) {
                    .w32 => try emitter.binop32("mul", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("mul", dst_preg, lhs_preg, rhs_preg),
                },
                .div_s => switch (op.width) {
                    .w32 => try emitter.binop32("sdiv", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("sdiv", dst_preg, lhs_preg, rhs_preg),
                },
                .div_u => switch (op.width) {
                    .w32 => try emitter.binop32("udiv", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("udiv", dst_preg, lhs_preg, rhs_preg),
                },
                else => {}, // TODO: implement remaining ops
            }
        },

        .cmp => |_| {
            // TODO: implement comparisons
        },

        .load_global => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            const name = globals.getName(op.global_idx);
            try emitter.loadGlobal(dst_preg, name, op.width);
        },

        .store_global => |op| {
            const src_preg = reg_map.get(op.src);
            const name = globals.getName(op.global_idx);
            try emitter.storeGlobal(src_preg, name, op.width);
        },

        .load_local => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            switch (op.width) {
                .w32 => try emitter.loadFpOffset32(dst_preg, op.offset),
                .w64 => try emitter.loadFpOffset64(dst_preg, op.offset),
            }
        },

        .store_local => |op| {
            const src_preg = reg_map.get(op.src);
            switch (op.width) {
                .w32 => try emitter.storeFpOffset32(src_preg, op.offset),
                .w64 => try emitter.storeFpOffset64(src_preg, op.offset),
            }
        },

        .ret => |op| {
            if (op.value) |vreg| {
                const src_preg = reg_map.get(vreg);
                // move result to w0/x0 (return register)
                switch (op.width) {
                    .w32 => try emitter.movReg32(0, src_preg),
                    .w64 => try emitter.movReg64(0, src_preg),
                }
            }
            // restore stack for locals
            if (func_state.frame_size > 0) {
                try emitter.addSpImm(func_state.frame_size);
            }
            // epilogue: restore frame pointer and link register
            try emitter.raw("ldp x29, x30, [sp], #16");
            try emitter.ret();
        },

        .prologue => {
            try emitter.raw("stp x29, x30, [sp, #-16]!");
            try emitter.raw("mov x29, sp");
            // allocate stack for locals
            if (func_state.frame_size > 0) {
                try emitter.subSpImm(func_state.frame_size);
            }
        },

        .epilogue => {
            if (func_state.frame_size > 0) {
                try emitter.addSpImm(func_state.frame_size);
            }
            try emitter.raw("ldp x29, x30, [sp], #16");
        },

        .call => |op| {
            // 1. Move arguments to x0-x7 (max 8 register args)
            for (op.args, 0..) |arg_vreg, i| {
                if (i >= 8) break;
                const src_preg = reg_map.get(arg_vreg);
                switch (op.width) {
                    .w32 => try emitter.movReg32(@intCast(i), src_preg),
                    .w64 => try emitter.movReg64(@intCast(i), src_preg),
                }
            }

            // 2. Emit bl with proper name mangling for C calling convention
            var label_buf: [128]u8 = undefined;
            const call_label = switch (op.call_conv) {
                .c => if (emitter.os == .darwin)
                    std.fmt.bufPrint(&label_buf, "_{s}", .{op.func_name}) catch unreachable
                else
                    op.func_name,
                else => op.func_name,
            };
            try emitter.bl(call_label);

            // 3. Move x0 result to destination vreg (if non-void)
            if (op.dst) |dst_vreg| {
                const dst_preg = reg_map.allocFor(dst_vreg);
                switch (op.width) {
                    .w32 => try emitter.movReg32(dst_preg, 0),
                    .w64 => try emitter.movReg64(dst_preg, 0),
                }
            }
        },
    }
}

/// Simple vreg -> preg mapping.
/// Uses x9-x15 as scratch registers, allocates linearly.
const RegMap = struct {
    map: [256]PReg = [_]PReg{0} ** 256,
    next_scratch: PReg = 9,

    fn allocFor(self: *RegMap, vreg: VReg) PReg {
        if (vreg < 256) {
            if (self.map[vreg] == 0 and vreg != 0) {
                self.map[vreg] = self.nextReg();
            }
            return self.map[vreg];
        }
        return self.nextReg();
    }

    fn get(self: *const RegMap, vreg: VReg) PReg {
        if (vreg < 256) {
            return self.map[vreg];
        }
        return 0;
    }

    fn nextReg(self: *RegMap) PReg {
        const reg = self.next_scratch;
        if (self.next_scratch < 15) {
            self.next_scratch += 1;
        } else {
            self.next_scratch = 9; // wrap around (will clobber, but ok for now)
        }
        return reg;
    }
};

/// ARM64 assembly emitter.
const Emitter = struct {
    allocator: mem.Allocator,
    buffer: std.ArrayList(u8),
    indent: []const u8,
    os: Os,

    fn init(allocator: mem.Allocator, os: Os) !Emitter {
        return .{
            .allocator = allocator,
            .buffer = try std.ArrayList(u8).initCapacity(allocator, 4096),
            .indent = "  ",
            .os = os,
        };
    }

    fn deinit(self: *Emitter) void {
        self.buffer.deinit(self.allocator);
    }

    fn getOutput(self: *const Emitter) []const u8 {
        return self.buffer.items;
    }

    // -- Directives --

    fn directive(self: *Emitter, dir: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, dir);
        try self.buffer.append(self.allocator, '\n');
    }

    fn label(self: *Emitter, name: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, name);
        try self.buffer.appendSlice(self.allocator, ":\n");
    }

    fn global(self: *Emitter, name: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, ".global ");
        try self.buffer.appendSlice(self.allocator, name);
        try self.buffer.append(self.allocator, '\n');
    }

    fn comment(self: *Emitter, msg: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, "; ");
        try self.buffer.appendSlice(self.allocator, msg);
        try self.buffer.append(self.allocator, '\n');
    }

    fn newline(self: *Emitter) !void {
        try self.buffer.append(self.allocator, '\n');
    }

    fn raw(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    // -- Instructions --

    fn ret(self: *Emitter) !void {
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, "ret\n");
    }

    fn movImm32(self: *Emitter, dst: PReg, value: i32) !void {
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, #{d}\n", .{ regName32(dst), value }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movImm64(self: *Emitter, dst: PReg, value: i64) !void {
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, #{d}\n", .{ regName64(dst), value }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movReg32(self: *Emitter, dst: PReg, src: PReg) !void {
        if (dst == src) return;
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, {s}\n", .{ regName32(dst), regName32(src) }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movReg64(self: *Emitter, dst: PReg, src: PReg) !void {
        if (dst == src) return;
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, {s}\n", .{ regName64(dst), regName64(src) }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn bl(self: *Emitter, target: []const u8) !void {
        var buf: [128]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "bl {s}\n", .{target}) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn binop32(self: *Emitter, op: []const u8, dst: PReg, lhs: PReg, rhs: PReg) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "{s} {s}, {s}, {s}\n", .{
            op,
            regName32(dst),
            regName32(lhs),
            regName32(rhs),
        }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn binop64(self: *Emitter, op: []const u8, dst: PReg, lhs: PReg, rhs: PReg) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "{s} {s}, {s}, {s}\n", .{
            op,
            regName64(dst),
            regName64(lhs),
            regName64(rhs),
        }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    // -- Global variable support --

    fn globalData(self: *Emitter, name: []const u8, width: Width, value: i64) !void {
        var buf: [128]u8 = undefined;

        // emit label with underscore prefix on Darwin
        const lbl = if (self.os == .darwin)
            std.fmt.bufPrint(&buf, "_{s}:\n", .{name}) catch unreachable
        else
            std.fmt.bufPrint(&buf, "{s}:\n", .{name}) catch unreachable;
        try self.buffer.appendSlice(self.allocator, lbl);

        // emit storage directive
        const storage = switch (width) {
            .w32 => std.fmt.bufPrint(&buf, "  .long {d}\n", .{value}) catch unreachable,
            .w64 => std.fmt.bufPrint(&buf, "  .quad {d}\n", .{value}) catch unreachable,
        };
        try self.buffer.appendSlice(self.allocator, storage);
    }

    fn loadGlobal(self: *Emitter, dst: PReg, name: []const u8, width: Width) !void {
        var buf: [128]u8 = undefined;

        // ARM64: Use ADRP + LDR pattern for PC-relative addressing
        if (self.os == .darwin) {
            const adrp = std.fmt.bufPrint(&buf, "adrp x16, _{s}@PAGE\n", .{name}) catch unreachable;
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, adrp);

            const ldr = switch (width) {
                .w32 => std.fmt.bufPrint(&buf, "ldr {s}, [x16, _{s}@PAGEOFF]\n", .{ regName32(dst), name }) catch unreachable,
                .w64 => std.fmt.bufPrint(&buf, "ldr {s}, [x16, _{s}@PAGEOFF]\n", .{ regName64(dst), name }) catch unreachable,
            };
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, ldr);
        } else {
            const adrp = std.fmt.bufPrint(&buf, "adrp x16, {s}\n", .{name}) catch unreachable;
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, adrp);

            const ldr = switch (width) {
                .w32 => std.fmt.bufPrint(&buf, "ldr {s}, [x16, :lo12:{s}]\n", .{ regName32(dst), name }) catch unreachable,
                .w64 => std.fmt.bufPrint(&buf, "ldr {s}, [x16, :lo12:{s}]\n", .{ regName64(dst), name }) catch unreachable,
            };
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, ldr);
        }
    }

    fn storeGlobal(self: *Emitter, src: PReg, name: []const u8, width: Width) !void {
        var buf: [128]u8 = undefined;

        // ARM64: Use ADRP + STR pattern
        if (self.os == .darwin) {
            const adrp = std.fmt.bufPrint(&buf, "adrp x16, _{s}@PAGE\n", .{name}) catch unreachable;
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, adrp);

            const str = switch (width) {
                .w32 => std.fmt.bufPrint(&buf, "str {s}, [x16, _{s}@PAGEOFF]\n", .{ regName32(src), name }) catch unreachable,
                .w64 => std.fmt.bufPrint(&buf, "str {s}, [x16, _{s}@PAGEOFF]\n", .{ regName64(src), name }) catch unreachable,
            };
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, str);
        } else {
            const adrp = std.fmt.bufPrint(&buf, "adrp x16, {s}\n", .{name}) catch unreachable;
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, adrp);

            const str = switch (width) {
                .w32 => std.fmt.bufPrint(&buf, "str {s}, [x16, :lo12:{s}]\n", .{ regName32(src), name }) catch unreachable,
                .w64 => std.fmt.bufPrint(&buf, "str {s}, [x16, :lo12:{s}]\n", .{ regName64(src), name }) catch unreachable,
            };
            try self.buffer.appendSlice(self.allocator, self.indent);
            try self.buffer.appendSlice(self.allocator, str);
        }
    }

    // -- Local variable support (fp-relative addressing) --

    fn loadFpOffset32(self: *Emitter, dst: PReg, offset: i16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "ldr {s}, [x29, #{d}]\n", .{ regName32(dst), offset }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn loadFpOffset64(self: *Emitter, dst: PReg, offset: i16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "ldr {s}, [x29, #{d}]\n", .{ regName64(dst), offset }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn storeFpOffset32(self: *Emitter, src: PReg, offset: i16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "str {s}, [x29, #{d}]\n", .{ regName32(src), offset }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn storeFpOffset64(self: *Emitter, src: PReg, offset: i16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "str {s}, [x29, #{d}]\n", .{ regName64(src), offset }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn subSpImm(self: *Emitter, imm: u16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "sub sp, sp, #{d}\n", .{imm}) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn addSpImm(self: *Emitter, imm: u16) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "add sp, sp, #{d}\n", .{imm}) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }
};

fn regName32(reg: PReg) []const u8 {
    const names = [_][]const u8{
        "w0", "w1", "w2",  "w3",  "w4",  "w5",  "w6",  "w7",
        "w8", "w9", "w10", "w11", "w12", "w13", "w14", "w15",
    };
    return names[reg];
}

fn regName64(reg: PReg) []const u8 {
    const names = [_][]const u8{
        "x0", "x1", "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
        "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
    };
    return names[reg];
}
