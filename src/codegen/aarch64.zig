const std = @import("std");
const mem = std.mem;

const mir = @import("mir.zig");
const MIRModule = mir.MIRModule;
const MIRFunction = mir.MIRFunction;
const MInst = mir.MInst;
const VReg = mir.VReg;
const Width = mir.Width;
const BinOp = mir.BinOp;

/// Physical register (x0-x15).
pub const PReg = u4;

/// Lower MIR module to ARM64 assembly.
pub fn lower(allocator: mem.Allocator, module: *const MIRModule) ![]const u8 {
    var emitter = try Emitter.init(allocator);
    defer emitter.deinit();

    // header
    try emitter.comment("Generated by the Honey compiler");
    try emitter.newline();
    try emitter.directive(".text");
    try emitter.directive(".align 2");
    try emitter.newline();

    // lower each function
    for (module.functions.items) |*func| {
        try lowerFunction(&emitter, func);
    }

    return try allocator.dupe(u8, emitter.getOutput());
}

fn lowerFunction(emitter: *Emitter, func: *const MIRFunction) !void {
    // function label (with underscore prefix for C ABI on Darwin)
    var label_buf: [128]u8 = undefined;
    const label = if (func.call_conv == .c)
        std.fmt.bufPrint(&label_buf, "_{s}", .{func.name}) catch unreachable
    else
        func.name;

    try emitter.global(label);
    try emitter.label(label);

    // simple register allocator: map vregs to physical regs
    var reg_map = RegMap{};

    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &reg_map);
    }

    try emitter.newline();
}

fn lowerInst(emitter: *Emitter, inst: MInst, reg_map: *RegMap) !void {
    switch (inst) {
        .mov_imm => |op| {
            const preg = reg_map.allocFor(op.dst);
            switch (op.width) {
                .w32 => try emitter.movImm32(preg, @truncate(@as(i64, op.value))),
                .w64 => try emitter.movImm64(preg, op.value),
            }
        },

        .mov_reg => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            const src_preg = reg_map.get(op.src);
            switch (op.width) {
                .w32 => try emitter.movReg32(dst_preg, src_preg),
                .w64 => try emitter.movReg64(dst_preg, src_preg),
            }
        },

        .binop => |op| {
            const dst_preg = reg_map.allocFor(op.dst);
            const lhs_preg = reg_map.get(op.lhs);
            const rhs_preg = reg_map.get(op.rhs);

            switch (op.op) {
                .add => switch (op.width) {
                    .w32 => try emitter.binop32("add", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("add", dst_preg, lhs_preg, rhs_preg),
                },
                .sub => switch (op.width) {
                    .w32 => try emitter.binop32("sub", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("sub", dst_preg, lhs_preg, rhs_preg),
                },
                .mul => switch (op.width) {
                    .w32 => try emitter.binop32("mul", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("mul", dst_preg, lhs_preg, rhs_preg),
                },
                .div_s => switch (op.width) {
                    .w32 => try emitter.binop32("sdiv", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("sdiv", dst_preg, lhs_preg, rhs_preg),
                },
                .div_u => switch (op.width) {
                    .w32 => try emitter.binop32("udiv", dst_preg, lhs_preg, rhs_preg),
                    .w64 => try emitter.binop64("udiv", dst_preg, lhs_preg, rhs_preg),
                },
                else => {}, // TODO: implement remaining ops
            }
        },

        .cmp => |_| {
            // TODO: implement comparisons
        },

        .ret => |op| {
            if (op.value) |vreg| {
                const src_preg = reg_map.get(vreg);
                // move result to w0/x0 (return register)
                switch (op.width) {
                    .w32 => try emitter.movReg32(0, src_preg),
                    .w64 => try emitter.movReg64(0, src_preg),
                }
            }
            // epilogue: restore frame pointer and link register
            try emitter.raw("ldp x29, x30, [sp], #16");
            try emitter.ret();
        },

        .prologue => {
            try emitter.raw("stp x29, x30, [sp, #-16]!");
            try emitter.raw("mov x29, sp");
        },

        .epilogue => {
            try emitter.raw("ldp x29, x30, [sp], #16");
        },
    }
}

/// Simple vreg -> preg mapping.
/// Uses x9-x15 as scratch registers, allocates linearly.
const RegMap = struct {
    map: [256]PReg = [_]PReg{0} ** 256,
    next_scratch: PReg = 9,

    fn allocFor(self: *RegMap, vreg: VReg) PReg {
        if (vreg < 256) {
            if (self.map[vreg] == 0 and vreg != 0) {
                self.map[vreg] = self.nextReg();
            }
            return self.map[vreg];
        }
        return self.nextReg();
    }

    fn get(self: *const RegMap, vreg: VReg) PReg {
        if (vreg < 256) {
            return self.map[vreg];
        }
        return 0;
    }

    fn nextReg(self: *RegMap) PReg {
        const reg = self.next_scratch;
        if (self.next_scratch < 15) {
            self.next_scratch += 1;
        } else {
            self.next_scratch = 9; // wrap around (will clobber, but ok for now)
        }
        return reg;
    }
};

/// ARM64 assembly emitter.
const Emitter = struct {
    allocator: mem.Allocator,
    buffer: std.ArrayList(u8),
    indent: []const u8,

    fn init(allocator: mem.Allocator) !Emitter {
        return .{
            .allocator = allocator,
            .buffer = try std.ArrayList(u8).initCapacity(allocator, 4096),
            .indent = "  ",
        };
    }

    fn deinit(self: *Emitter) void {
        self.buffer.deinit(self.allocator);
    }

    fn getOutput(self: *const Emitter) []const u8 {
        return self.buffer.items;
    }

    // -- Directives --

    fn directive(self: *Emitter, dir: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, dir);
        try self.buffer.append(self.allocator, '\n');
    }

    fn label(self: *Emitter, name: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, name);
        try self.buffer.appendSlice(self.allocator, ":\n");
    }

    fn global(self: *Emitter, name: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, ".global ");
        try self.buffer.appendSlice(self.allocator, name);
        try self.buffer.append(self.allocator, '\n');
    }

    fn comment(self: *Emitter, msg: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, "; ");
        try self.buffer.appendSlice(self.allocator, msg);
        try self.buffer.append(self.allocator, '\n');
    }

    fn newline(self: *Emitter) !void {
        try self.buffer.append(self.allocator, '\n');
    }

    fn raw(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    // -- Instructions --

    fn ret(self: *Emitter) !void {
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, "ret\n");
    }

    fn movImm32(self: *Emitter, dst: PReg, value: i32) !void {
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, #{d}\n", .{ regName32(dst), value }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movImm64(self: *Emitter, dst: PReg, value: i64) !void {
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, #{d}\n", .{ regName64(dst), value }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movReg32(self: *Emitter, dst: PReg, src: PReg) !void {
        if (dst == src) return;
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, {s}\n", .{ regName32(dst), regName32(src) }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn movReg64(self: *Emitter, dst: PReg, src: PReg) !void {
        if (dst == src) return;
        var buf: [32]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "mov {s}, {s}\n", .{ regName64(dst), regName64(src) }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn binop32(self: *Emitter, op: []const u8, dst: PReg, lhs: PReg, rhs: PReg) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "{s} {s}, {s}, {s}\n", .{
            op,
            regName32(dst),
            regName32(lhs),
            regName32(rhs),
        }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }

    fn binop64(self: *Emitter, op: []const u8, dst: PReg, lhs: PReg, rhs: PReg) !void {
        var buf: [48]u8 = undefined;
        const instr = std.fmt.bufPrint(&buf, "{s} {s}, {s}, {s}\n", .{
            op,
            regName64(dst),
            regName64(lhs),
            regName64(rhs),
        }) catch unreachable;
        try self.buffer.appendSlice(self.allocator, self.indent);
        try self.buffer.appendSlice(self.allocator, instr);
    }
};

fn regName32(reg: PReg) []const u8 {
    const names = [_][]const u8{
        "w0", "w1", "w2",  "w3",  "w4",  "w5",  "w6",  "w7",
        "w8", "w9", "w10", "w11", "w12", "w13", "w14", "w15",
    };
    return names[reg];
}

fn regName64(reg: PReg) []const u8 {
    const names = [_][]const u8{
        "x0", "x1", "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
        "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
    };
    return names[reg];
}
