const std = @import("std");
const mem = @import("std").mem;

const ComptimeResult = @import("../comptime/comptime.zig").ComptimeResult;
const SymbolTable = @import("../semantic/symbols.zig").SymbolTable;
const Ast = @import("../parser/ast.zig").Ast;
const NodeIndex = @import("../parser/ast.zig").NodeIndex;
const NodeKind = @import("../parser/ast.zig").NodeKind;
const TokenList = @import("../lexer/token.zig").TokenList;
const SourceCode = @import("../source/source.zig").SourceCode;

const arm64 = @import("arm64.zig");
const Arm64Emitter = @import("arm64.zig").Arm64Emitter;
const Arm64Registers = @import("arm64.zig").Arm64Registers;

pub const linker = @import("linker.zig");

pub fn generate(
    allocator: mem.Allocator,
    target: Target,
    comptime_result: *const ComptimeResult,
    symbols: *const SymbolTable,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
) !CodeGenResult {
    var ctx = try CodeGenContext.init(
        allocator,
        target,
        comptime_result,
        symbols,
        ast,
        tokens,
        src,
    );
    defer ctx.deinit();
    return try ctx.generate();
}

pub const CodeGenContext = struct {
    allocator: mem.Allocator,
    comptime_result: *const ComptimeResult,
    symbols: *const SymbolTable,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
    emitter: AsmEmitter,
    registers: Arm64Registers,

    pub fn init(
        allocator: mem.Allocator,
        target: Target,
        comptime_result: *const ComptimeResult,
        symbols: *const SymbolTable,
        ast: *const Ast,
        tokens: *const TokenList,
        src: *const SourceCode,
    ) !CodeGenContext {
        return .{
            .allocator = allocator,
            .comptime_result = comptime_result,
            .symbols = symbols,
            .ast = ast,
            .tokens = tokens,
            .src = src,
            .emitter = try AsmEmitter.init(allocator, target),
            .registers = .{},
        };
    }

    pub fn deinit(self: *CodeGenContext) void {
        self.emitter.deinit();
    }

    pub fn generate(self: *CodeGenContext) !CodeGenResult {
        // emit assembly header
        try self.emitter.comment("Generated by the Honey compiler", null);
        try self.emitter.newline();

        try self.emitter.directive(".text");
        try self.emitter.directive(".align 2");
        try self.emitter.newline();

        // process all declarations
        const program = self.ast.getProgram(self.ast.root);
        const declarations = self.ast.getExtra(program.declarations);

        for (declarations) |decl_idx| {
            try self.generateDeclaration(decl_idx);
        }

        // return owned copy of assembly
        const output = try self.allocator.dupe(u8, self.emitter.getOutput());
        return .{ .assembly = output };
    }

    fn generateDeclaration(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const kind = self.ast.getKind(node_idx);

        switch (kind) {
            .func_decl => try self.generateFunction(node_idx),
            .const_decl, .var_decl => {
                // global constants/variables handled at data section
                // for now, skip (comptime evaluates constants)
            },
            else => {},
        }
    }

    fn generateFunction(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const func = self.ast.getFuncDecl(node_idx);

        // skip external functions (no body)
        if (func.body == null) return;

        // get func name
        const name_ident = self.ast.getIdentifier(func.name);
        const name_token = self.tokens.items[name_ident.token_idx];
        const func_name = self.src.getSlice(name_token.start, name_token.start + name_token.len);

        // darwin requires underscore prefix for c symbols
        var label_buf: [128]u8 = undefined;
        const label = if (func.calling_conv == .c or std.mem.eql(u8, func_name, "main"))
            std.fmt.bufPrint(&label_buf, "_{s}", .{func_name}) catch unreachable
        else
            func_name;

        // emit func header
        try self.emitter.global(label);
        try self.emitter.label(label);

        // emit prologue
        // try self.emitter.comment("prologue start", self.emitter.getIndent());
        // try self.emitter.funcPrologue();
        // try self.emitter.comment("prologue end\n", self.emitter.getIndent());

        // emit body
        const has_return = try self.generateBlock(func.body.?);

        if (!has_return) {
            // ONLY ALLOWED IF RETURN TYPE VOID

            // return zero (success code)
            switch (self.emitter) {
                .arm64 => |*emitter| try emitter.movImm32(0, 0),
            }

            try self.emitter.newline();

            // emit epilogue
            // try self.emitter.comment("epilogue start", self.emitter.getIndent());
            // try self.emitter.funcEpilogue();
            // try self.emitter.comment("epilogue end\n", self.emitter.getIndent());

            try self.emitter.ret();
            try self.emitter.newline();
        }
    }

    fn generateBlock(self: *CodeGenContext, node_idx: NodeIndex) !bool {
        var has_return = false;

        const block = self.ast.getBlock(node_idx);
        const statements = self.ast.getExtra(block.statements);
        const deferred = self.ast.getExtra(block.deferred);

        for (statements) |stmt_idx| {
            // TODO: make sure that deferred statements are run in case of early return
            const kind = try self.generateStatement(stmt_idx);
            has_return = has_return or (kind == .return_stmt);
        }

        // execute deferred statements in reverse order
        var i = deferred.len;
        while (i > 0) {
            i -= 1;
            _ = try self.generateStatement(deferred[i]);
        }

        try self.emitter.newline();
        return has_return;
    }

    fn generateStatement(self: *CodeGenContext, node_idx: NodeIndex) !?NodeKind {
        const kind = self.ast.getKind(node_idx);
        switch (kind) {
            .return_stmt => try self.generateReturn(node_idx),
            else => return null,
        }
        return kind;

        // NOTE: remember to reset registers between statements
    }

    fn generateReturn(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const ret = self.ast.getReturn(node_idx);

        // generate return expression (result in w0/x0)
        const result_reg = try self.generateExpression(ret.expr) orelse {
            // expression didn't produce a value, return 0
            switch (self.emitter) {
                .arm64 => |*e| try e.movImm32(0, 0), // mov w0, #0
            }
            try self.emitter.ret();
            return;
        };

        // move result to x0/w0 if not already there
        switch (self.emitter) {
            .arm64 => |*e| try e.movReg32(0, result_reg),
        }

        // free the register (safe even if it's x0)
        self.registers.safeFree(result_reg);

        try self.emitter.newline();
        try self.emitter.ret();
    }

    fn generateExpression(self: *CodeGenContext, node_idx: NodeIndex) CodeGenError!?arm64.Register {
        // TODO: return register that holds result
        const kind = self.ast.getKind(node_idx);
        return switch (kind) {
            .literal => try self.generateLiteral(node_idx),
            .identifier => try self.generateIdentifier(node_idx),
            .binary_op => try self.generateBinaryOp(node_idx),
            else => null,
        };
    }

    fn generateLiteral(self: *CodeGenContext, node_idx: NodeIndex) !?arm64.Register {
        const lit = self.ast.getLiteral(node_idx);
        const token = self.tokens.items[lit.token_idx];
        const value_str = self.src.getSlice(token.start, token.start + token.len);

        const dst = self.registers.alloc() orelse return error.OutOfMemory; // TODO: spill

        switch (token.kind) {
            .bool => {
                const value: i32 = if (std.mem.eql(u8, value_str, "true")) 1 else 0;
                switch (self.emitter) {
                    .arm64 => |*emitter| try emitter.movImm32(dst, value),
                }
            },
            .number => {
                // FIXME: ASSUMES NUMBER IS i32
                const value = std.fmt.parseInt(i32, value_str, 10) catch 0;
                switch (self.emitter) {
                    .arm64 => |*emitter| try emitter.movImm32(dst, value),
                }
            },
            else => {
                self.registers.free(dst);
                return null;
            },
        }

        return dst;
    }

    fn generateIdentifier(self: *CodeGenContext, node_idx: NodeIndex) !?arm64.Register {
        // FIXME: ASSUMES CONST DECLARATION

        const ident = self.ast.getIdentifier(node_idx);
        const token = self.tokens.items[ident.token_idx];
        const name = self.src.getSlice(token.start, token.start + token.len);

        // look up symbol
        const sym_idx = self.symbols.lookup(name) orelse return null;
        const type_id = self.symbols.getTypeId(sym_idx);
        const kind = self.symbols.getKind(sym_idx);
        const eval_state = self.comptime_result.eval_states.items[sym_idx];
        const value_str = self.comptime_result.getEvalLiteral(sym_idx) orelse return null;

        const dst = self.registers.alloc() orelse return error.OutOfMemory; // TODO: spill

        if (kind != .constant and eval_state != .evaluated) return null;
        switch (type_id) {
            .primitive => |prim| {
                switch (prim) {
                    .i32 => {
                        const value = std.fmt.parseInt(i32, value_str, 10) catch 0;
                        switch (self.emitter) {
                            .arm64 => |*emitter| try emitter.movImm32(dst, value),
                        }
                    },
                    else => {
                        self.registers.free(dst);
                        return null;
                    },
                }
            },
            else => {
                self.registers.free(dst);
                return null;
            },
        }

        return dst;

        // const value_node = self.symbols.getValueNode(sym_idx);

        // generate value expression
        // return try self.generateExpression(value_node);
    }

    fn generateBinaryOp(self: *CodeGenContext, node_idx: NodeIndex) !?arm64.Register {
        const binary = self.ast.getBinaryOp(node_idx);

        const left_reg = try self.generateExpression(binary.left) orelse return null;
        const right_reg = try self.generateExpression(binary.right) orelse {
            self.registers.safeFree(left_reg);
            return null;
        };

        switch (self.emitter) {
            .arm64 => |*e| switch (binary.op) {
                .add => try e.addReg32(left_reg, left_reg, right_reg),
                else => {
                    // TODO: comparisons, logical ops
                },
            },
        }

        // free right, return left
        self.registers.safeFree(right_reg);
        return left_reg;
    }
};

pub const CodeGenError = error{
    OutOfMemory,
    UnsupportedFeature,
};

pub const CodeGenResult = struct {
    assembly: []const u8,
};

pub const Target = enum {
    arm64,
};

pub const AsmEmitter = union(Target) {
    arm64: Arm64Emitter,

    pub fn init(allocator: mem.Allocator, target: Target) !AsmEmitter {
        return switch (target) {
            .arm64 => AsmEmitter{ .arm64 = try Arm64Emitter.init(allocator) },
        };
    }

    pub fn deinit(self: *AsmEmitter) void {
        switch (self.*) {
            .arm64 => |*emitter| emitter.deinit(),
        }
    }

    pub fn getOutput(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.getOutput(),
        };
    }

    pub fn getIndent(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.indent,
        };
    }

    // DIRECTIVES

    pub fn directive(self: *AsmEmitter, dir: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.directive(dir),
        }
    }

    pub fn label(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.label(name),
        }
    }

    pub fn global(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.global(name),
        }
    }

    pub fn comment(self: *AsmEmitter, msg: []const u8, prefix: ?[]const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.comment(msg, prefix),
        }
    }

    pub fn newline(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.newline(),
        }
    }

    // INSTRUCTIONS

    pub fn ret(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.ret(),
        }
    }

    // COMPOUND

    pub fn funcPrologue(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.funcPrologue(),
        }
    }

    pub fn funcEpilogue(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.funcEpilogue(),
        }
    }
};
