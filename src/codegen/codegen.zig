const std = @import("std");
const mem = @import("std").mem;

const SymbolTable = @import("../semantic/symbols.zig").SymbolTable;
const Ast = @import("../parser/ast.zig").Ast;
const NodeIndex = @import("../parser/ast.zig").NodeIndex;
const NodeKind = @import("../parser/ast.zig").NodeKind;
const TokenList = @import("../lexer/token.zig").TokenList;
const SourceCode = @import("../source/source.zig").SourceCode;

const arm64 = @import("arm64.zig");
const Arm64Emitter = @import("arm64.zig").Arm64Emitter;

pub fn generate(
    allocator: mem.Allocator,
    target: Target,
    symbols: *const SymbolTable,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
) !CodeGenResult {
    var ctx = try CodeGenContext.init(allocator, target, symbols, ast, tokens, src);
    defer ctx.deinit();
    return try ctx.generate();
}

pub const CodeGenError = error{
    OutOfMemory,
    UnsupportedFeature,
};

pub const CodeGenResult = struct {
    assembly: []const u8,
};

pub const Target = enum {
    arm64,
};

pub const AsmEmitter = union(Target) {
    arm64: Arm64Emitter,

    pub fn init(allocator: mem.Allocator, target: Target) !AsmEmitter {
        return switch (target) {
            .arm64 => AsmEmitter{ .arm64 = try Arm64Emitter.init(allocator) },
        };
    }

    pub fn deinit(self: *AsmEmitter) void {
        switch (self.*) {
            .arm64 => |*emitter| emitter.deinit(),
        }
    }

    pub fn getOutput(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.getOutput(),
        };
    }

    pub fn getIndent(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.indent,
        };
    }

    // DIRECTIVES

    pub fn directive(self: *AsmEmitter, dir: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.directive(dir),
        }
    }

    pub fn label(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.label(name),
        }
    }

    pub fn global(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.global(name),
        }
    }

    pub fn comment(self: *AsmEmitter, msg: []const u8, prefix: ?[]const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.comment(msg, prefix),
        }
    }

    pub fn newline(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.newline(),
        }
    }

    // INSTRUCTIONS

    pub fn ret(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.ret(),
        }
    }

    // COMPOUND

    pub fn funcPrologue(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.funcPrologue(),
        }
    }

    pub fn funcEpilogue(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.funcEpilogue(),
        }
    }
};

pub const CodeGenContext = struct {
    allocator: mem.Allocator,
    symbols: *const SymbolTable,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
    emitter: AsmEmitter,

    pub fn init(
        allocator: mem.Allocator,
        target: Target,
        symbols: *const SymbolTable,
        ast: *const Ast,
        tokens: *const TokenList,
        src: *const SourceCode,
    ) !CodeGenContext {
        return .{
            .allocator = allocator,
            .symbols = symbols,
            .ast = ast,
            .tokens = tokens,
            .src = src,
            .emitter = try AsmEmitter.init(allocator, target),
        };
    }

    pub fn deinit(self: *CodeGenContext) void {
        self.emitter.deinit();
    }

    pub fn generate(self: *CodeGenContext) !CodeGenResult {
        // emit assembly header
        try self.emitter.comment("Generated by the Honey compiler", null);
        try self.emitter.newline();

        try self.emitter.directive(".text");
        try self.emitter.newline();

        // process all declarations
        const program = self.ast.getProgram(self.ast.root);
        const declarations = self.ast.getExtra(program.declarations);

        for (declarations) |decl_idx| {
            try self.generateDeclaration(decl_idx);
        }

        // return owned copy of assembly
        const output = try self.allocator.dupe(u8, self.emitter.getOutput());
        return .{ .assembly = output };
    }

    fn generateDeclaration(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const kind = self.ast.getKind(node_idx);

        switch (kind) {
            .func_decl => try self.generateFunction(node_idx),
            .const_decl, .var_decl => {
                // global constants/variables handled at data section
                // for now, skip (comptime evaluates constants)
            },
            else => {},
        }
    }

    fn generateFunction(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const func = self.ast.getFuncDecl(node_idx);

        // skip external functions (no body)
        if (func.body == null) return;

        // get func name
        const name_ident = self.ast.getIdentifier(func.name);
        const name_token = self.tokens.items[name_ident.token_idx];
        const func_name = self.src.getSlice(name_token.start, name_token.start + name_token.len);

        // darwin requires underscore prefix for c symbols
        var label_buf: [128]u8 = undefined;
        const label = if (func.calling_conv == .c or std.mem.eql(u8, func_name, "main"))
            std.fmt.bufPrint(&label_buf, "_{s}", .{func_name}) catch unreachable
        else
            func_name;

        // emit func header
        try self.emitter.global(label);
        try self.emitter.label(label);

        // emit prologue
        try self.emitter.comment("prologue start", self.emitter.getIndent());
        try self.emitter.funcPrologue();
        try self.emitter.comment("prologue end\n", self.emitter.getIndent());

        // emit body
        const has_return = try self.generateBlock(func.body.?);

        if (!has_return) {
            // ONLY ALLOWED IF RETURN TYPE VOID

            // return zero (success code)
            switch (self.emitter) {
                .arm64 => |*emitter| try emitter.emitMovImmU32(.w0, 0),
            }

            try self.emitter.newline();

            // emit epilogue
            try self.emitter.comment("epilogue start", self.emitter.getIndent());
            try self.emitter.funcEpilogue();
            try self.emitter.comment("epilogue end\n", self.emitter.getIndent());

            try self.emitter.ret();
            try self.emitter.newline();
        }
    }

    fn generateBlock(self: *CodeGenContext, node_idx: NodeIndex) !bool {
        var has_return = false;

        const block = self.ast.getBlock(node_idx);
        const statements = self.ast.getExtra(block.statements);
        const deferred = self.ast.getExtra(block.deferred);

        try self.emitter.comment("function body start\n", self.emitter.getIndent());

        for (statements) |stmt_idx| {
            // TODO: make sure that deferred statements are run in case of early return
            const kind = try self.generateStatement(stmt_idx);
            has_return = has_return or (kind == .return_stmt);
        }

        // execute deferred statements in reverse order
        var i = deferred.len;
        while (i > 0) {
            i -= 1;
            _ = try self.generateStatement(deferred[i]);
        }

        try self.emitter.newline();
        try self.emitter.comment("function body end\n", self.emitter.getIndent());

        return has_return;
    }

    fn generateStatement(self: *CodeGenContext, node_idx: NodeIndex) !?NodeKind {
        const kind = self.ast.getKind(node_idx);
        switch (kind) {
            .return_stmt => try self.generateReturn(node_idx),
            else => return null,
        }
        return kind;

        // NOTE: remember to reset registers between statements
    }

    fn generateReturn(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const ret = self.ast.getReturn(node_idx);

        // generate return expression (result in w0/x0)
        try self.generateExpression(ret.expr);
        try self.emitter.newline();

        // emit epilogue
        try self.emitter.comment("epilogue start", self.emitter.getIndent());
        try self.emitter.funcEpilogue();
        try self.emitter.comment("epilogue end\n", self.emitter.getIndent());

        try self.emitter.ret();
    }

    fn generateExpression(self: *CodeGenContext, node_idx: NodeIndex) CodeGenError!void {
        // TODO: return register that holds result
        const kind = self.ast.getKind(node_idx);
        switch (kind) {
            .literal => try self.generateLiteral(node_idx),
            .identifier => try self.generateIdentifier(node_idx),
            else => {},
        }
    }

    fn generateLiteral(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const lit = self.ast.getLiteral(node_idx);
        const token = self.tokens.items[lit.token_idx];
        const value_str = self.src.getSlice(token.start, token.start + token.len);

        switch (token.kind) {
            .bool => {
                const value: u32 = if (std.mem.eql(u8, value_str, "true")) 1 else 0;
                switch (self.emitter) {
                    .arm64 => |*emitter| try emitter.emitMovImmU32(.w0, value),
                }
            },
            .number => {
                // FIXME: ASSUMES NUMBER IS i32
                const value = std.fmt.parseInt(i32, value_str, 10) catch 0;
                switch (self.emitter) {
                    .arm64 => |*emitter| try emitter.emitMovImmI32(.w0, value),
                }
            },
            else => {},
        }

        // TODO: return result register
    }

    fn generateIdentifier(self: *CodeGenContext, node_idx: NodeIndex) !void {
        // FIXME: ASSUMES CONST DECLARATION

        const ident = self.ast.getIdentifier(node_idx);
        const token = self.tokens.items[ident.token_idx];
        const name = self.src.getSlice(token.start, token.start + token.len);

        // look up symbol
        const sym_idx = self.symbols.lookup(name) orelse return;
        const value_node = self.symbols.getValueNode(sym_idx);

        // generate value expression
        try self.generateExpression(value_node);
    }
};
