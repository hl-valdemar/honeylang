const std = @import("std");
const mem = @import("std").mem;

const Ast = @import("../parser/ast.zig").Ast;
const NodeIndex = @import("../parser/ast.zig").NodeIndex;
const TokenList = @import("../lexer/token.zig").TokenList;
const SourceCode = @import("../source/source.zig").SourceCode;

const Arm64Emitter = @import("arm64.zig").Arm64Emitter;

pub fn generate(
    allocator: mem.Allocator,
    target: Target,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
) !CodeGenResult {
    var ctx = try CodeGenContext.init(allocator, target, ast, tokens, src);
    defer ctx.deinit();
    return try ctx.generate();
}

pub const CodeGenError = error{
    OutOfMemory,
    UnsupportedFeature,
};

pub const CodeGenResult = struct {
    assembly: []const u8,
};

pub const Target = enum {
    arm64,
};

pub const AsmEmitter = union(Target) {
    arm64: Arm64Emitter,

    pub fn init(allocator: mem.Allocator, target: Target) !AsmEmitter {
        return switch (target) {
            .arm64 => AsmEmitter{ .arm64 = try Arm64Emitter.init(allocator) },
        };
    }

    pub fn deinit(self: *AsmEmitter) void {
        switch (self.*) {
            .arm64 => |*emitter| emitter.deinit(),
        }
    }

    pub fn getOutput(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.getOutput(),
        };
    }

    // DIRECTIVES

    pub fn emitDirective(self: *AsmEmitter, directive: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitDirective(directive),
        }
    }

    pub fn emitLabel(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitLabel(name),
        }
    }

    pub fn emitGlobal(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitGlobal(name),
        }
    }

    pub fn emitComment(self: *AsmEmitter, comment: []const u8, prefix: ?[]const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitComment(comment, prefix),
        }
    }

    pub fn emitNewline(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitNewline(),
        }
    }

    // INSTRUCTIONS

    pub fn emitRet(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitRet(),
        }
    }
};

pub const CodeGenContext = struct {
    allocator: mem.Allocator,
    ast: *const Ast,
    tokens: *const TokenList,
    src: *const SourceCode,
    emitter: AsmEmitter,

    pub fn init(
        allocator: mem.Allocator,
        target: Target,
        ast: *const Ast,
        tokens: *const TokenList,
        src: *const SourceCode,
    ) !CodeGenContext {
        return .{
            .allocator = allocator,
            .ast = ast,
            .tokens = tokens,
            .src = src,
            .emitter = try AsmEmitter.init(allocator, target),
        };
    }

    pub fn deinit(self: *CodeGenContext) void {
        self.emitter.deinit();
    }

    pub fn generate(self: *CodeGenContext) !CodeGenResult {
        // emit assembly header
        try self.emitter.emitComment("Generated by the Honey compiler", null);
        try self.emitter.emitNewline();

        try self.emitter.emitDirective(".text");
        try self.emitter.emitNewline();

        // process all declarations
        const program = self.ast.getProgram(self.ast.root);
        const declarations = self.ast.getExtra(program.declarations);

        for (declarations) |decl_idx| {
            try self.generateDeclaration(decl_idx);
        }

        // return owned copy of assembly
        const output = try self.allocator.dupe(u8, self.emitter.getOutput());
        return .{ .assembly = output };
    }

    fn generateDeclaration(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const kind = self.ast.getKind(node_idx);

        switch (kind) {
            .func_decl => try self.generateFunction(node_idx),
            .const_decl, .var_decl => {
                // global constants/variables handled at data section
                // for now, skip (comptime evaluates constants)
            },
            else => {},
        }
    }

    fn generateFunction(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const func = self.ast.getFuncDecl(node_idx);

        // skip external functions (no body)
        if (func.body == null) return;

        // get func name
        const name_ident = self.ast.getIdentifier(func.name);
        const name_token = self.tokens.items[name_ident.token_idx];
        const func_name = self.src.getSlice(name_token.start, name_token.start + name_token.len);

        // darwin requires underscore prefix for c symbols
        var label_buf: [128]u8 = undefined;
        const label = if (func.calling_conv == .c or std.mem.eql(u8, func_name, "main"))
            std.fmt.bufPrint(&label_buf, "_{s}", .{func_name}) catch unreachable
        else
            func_name;

        // emit func header
        try self.emitter.emitGlobal(label);
        try self.emitter.emitLabel(label);

        // emit prologue
        try self.emitPrologue();

        // emit body
        try self.generateBlock(func.body.?);

        // emit epilogue
        try self.emitEpilogue();
        try self.emitter.emitRet();

        try self.emitter.emitNewline();
    }

    fn emitPrologue(self: *CodeGenContext) !void {
        try self.emitter.emitComment("::prologue::");
        // TODO: save frame pointer and link register (and allocate stack frame)
        try self.emitter.emitNewline();
    }

    fn emitEpilogue(self: *CodeGenContext) !void {
        try self.emitter.emitComment("::epilogue::");
        // TODO: restore frame pointer and link register, and deallocate stack frame
        try self.emitter.emitNewline();
    }

    fn generateBlock(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const block = self.ast.getBlock(node_idx);
        const statements = self.ast.getExtra(block.statements);
        const deferred = self.ast.getExtra(block.deferred);

        try self.emitter.emitComment("::function body::");

        for (statements) |stmt_idx| {
            // TODO: generate statement (make sure that deferred statements are run in case of early return)
            _ = stmt_idx;
            try self.emitter.emitComment("statement placeholder");
        }

        // execute deferred statements in reverse order
        var i = deferred.len;
        while (i > 0) {
            i -= 1;
            // TODO: generate deferred statement
            try self.emitter.emitComment("deferred placeholder");
        }

        try self.emitter.emitNewline();
    }

    fn generateStatement(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const kind = self.ast.getKind(node_idx);
        switch (kind) {
            .return_stmt => try self.generateReturn(node_idx),
            else => {},
        }

        // NOTE: remember to reset registers between statements
    }

    fn generateReturn(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const ret = self.ast.getReturn(node_idx);
        _ = ret;

        // TODO: generate expression
        // TODO: move result to return register

        try self.emitEpilogue();
        try self.emitter.emitRet();
    }

    fn generateExpression(self: *CodeGenContext, node_idx: NodeIndex) !void {
        // TODO: return register that holds result
        const kind = self.ast.getKind(node_idx);
        switch (kind) {
            .literal => try self.generateLiteral(node_idx),
            else => {},
        }
    }

    fn generateLiteral(self: *CodeGenContext, node_idx: NodeIndex) !void {
        const lit = self.ast.getLiteral(node_idx);
        const token = self.tokens.items[lit.token_idx];
        const value_str = self.src.getSlice(token.start, token.start + token.len);
        _ = value_str;

        // TODO: allocate register for result

        if (token.kind == .@"bool") {
            // TODO: convert bool to int and store
        } else {
            // TODO: store numeric value
            // also, support more than just bools and numbers
        }

        // TODO: return result register
    }
};
