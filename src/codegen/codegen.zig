const std = @import("std");
const mem = @import("std").mem;

const Arm64Emitter = @import("arm64.zig").Arm64Emitter;

pub fn generate(allocator: mem.Allocator, target: Target) !CodeGenResult {
    var ctx = try CodeGenContext.init(allocator, target);
    defer ctx.deinit();
    return try ctx.generate();
}

pub const CodeGenError = error{
    OutOfMemory,
    UnsupportedFeature,
};

pub const CodeGenResult = struct {
    assembly: []const u8,
};

pub const Target = enum {
    arm64,
};

pub const AsmEmitter = union(Target) {
    arm64: Arm64Emitter,

    pub fn init(allocator: mem.Allocator, target: Target) !AsmEmitter {
        return switch (target) {
            .arm64 => AsmEmitter{ .arm64 = try Arm64Emitter.init(allocator) },
        };
    }

    pub fn deinit(self: *AsmEmitter) void {
        switch (self.*) {
            .arm64 => |*emitter| emitter.deinit(),
        }
    }

    pub fn getOutput(self: *const AsmEmitter) []const u8 {
        return switch (self.*) {
            .arm64 => |emitter| emitter.getOutput(),
        };
    }

    pub fn emitDirective(self: *AsmEmitter, directive: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitDirective(directive),
        }
    }

    pub fn emitLabel(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitLabel(name),
        }
    }

    pub fn emitGlobal(self: *AsmEmitter, name: []const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitGlobal(name),
        }
    }

    pub fn emitComment(self: *AsmEmitter, comment: []const u8, prefix: ?[]const u8) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitComment(comment, prefix),
        }
    }

    pub fn emitNewline(self: *AsmEmitter) !void {
        switch (self.*) {
            .arm64 => |*emitter| try emitter.emitNewline(),
        }
    }
};

pub const CodeGenContext = struct {
    allocator: mem.Allocator,
    emitter: AsmEmitter,

    pub fn init(allocator: mem.Allocator, target: Target) !CodeGenContext {
        return .{
            .allocator = allocator,
            .emitter = try AsmEmitter.init(allocator, target),
        };
    }

    pub fn deinit(self: *CodeGenContext) void {
        self.emitter.deinit();
    }

    pub fn generate(self: *CodeGenContext) !CodeGenResult {
        // emit assembly header
        try self.emitter.emitComment("Generated by the Honey compiler", null);
        try self.emitter.emitNewline();

        try self.emitter.emitDirective(".text");
        try self.emitter.emitNewline();

        // return owned copy of assembly
        const output = try self.allocator.dupe(u8, self.emitter.getOutput());
        return .{ .assembly = output };
    }
};
