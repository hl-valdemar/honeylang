const std = @import("std");
const mem = std.mem;

const mir = @import("mir.zig");
const MIRModule = mir.MIRModule;
const MIRFunction = mir.MIRFunction;
const MInst = mir.MInst;
const VReg = mir.VReg;
const Width = mir.Width;
const BinOp = mir.BinOp;
const CmpOp = mir.CmpOp;
const GlobalVars = mir.GlobalVars;

const codegen = @import("codegen.zig");
const Target = codegen.Target;

const CallingConvention = @import("../parser/ast.zig").CallingConvention;

/// Lower MIR module to LLVM IR text format.
pub fn lower(allocator: mem.Allocator, module: *const MIRModule, target: Target) ![]const u8 {
    var emitter = try Emitter.init(allocator, target);
    defer emitter.deinit();

    // module header
    try emitter.comment("Generated by the Honey compiler");
    try emitter.raw("source_filename = \"honey\"");
    try emitter.appendFmt("target triple = \"{s}\"\n", .{target.getLLVMTriple()});
    try emitter.newline();

    // emit global variable declarations
    try emitGlobals(&emitter, &module.globals);

    // emit extern function declarations
    for (module.extern_functions.items) |ext| {
        try emitExternDecl(&emitter, &ext);
    }
    if (module.extern_functions.items.len > 0) {
        try emitter.newline();
    }

    // emit function definitions
    var has_main = false;
    for (module.functions.items) |*func| {
        if (std.mem.eql(u8, func.name, "main")) has_main = true;
        try lowerFunction(&emitter, func, &module.globals);
    }

    // emit trap stub if no main function was defined
    if (!has_main) {
        try emitter.raw("declare void @llvm.trap() noreturn nounwind");
        try emitter.newline();
        try emitter.raw("define i32 @main() {");
        try emitter.raw("entry:");
        try emitter.raw("  call void @llvm.trap()");
        try emitter.raw("  unreachable");
        try emitter.raw("}");
        try emitter.newline();
    }

    // register __honey_init as a global constructor so it runs before main
    try emitter.raw("@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__honey_init, ptr null }]");
    try emitter.newline();

    return try allocator.dupe(u8, emitter.getOutput());
}

fn emitGlobals(emitter: *Emitter, globals: *const GlobalVars) !void {
    for (0..globals.count()) |i| {
        const idx: mir.GlobalIndex = @intCast(i);
        const name = globals.getName(idx);
        const width = globals.getWidth(idx);
        const type_str = widthToLLVMType(width);
        const init_value = globals.getInitValue(idx);

        if (init_value) |val| {
            try emitter.appendFmt("@{s} = global {s} {d}\n", .{ name, type_str, val });
        } else {
            // runtime-initialized, start as zero
            try emitter.appendFmt("@{s} = global {s} 0\n", .{ name, type_str });
        }
    }
    if (globals.count() > 0) {
        try emitter.newline();
    }
}

fn emitExternDecl(emitter: *Emitter, ext: *const mir.ExternFunc) !void {
    const cc_attr = ccAttr(ext.call_conv);
    const ret_str = if (ext.return_width) |w| widthToLLVMType(w) else "void";

    try emitter.appendFmt("declare {s}{s} @{s}(", .{ cc_attr, ret_str, ext.name });

    for (ext.param_widths, 0..) |pw, j| {
        if (j > 0) try emitter.appendSlice(", ");
        try emitter.appendSlice(widthToLLVMType(pw));
    }

    try emitter.appendSlice(")\n");
}

fn lowerFunction(emitter: *Emitter, func: *const MIRFunction, globals: *const GlobalVars) !void {
    const cc_attr = ccAttr(func.call_conv);
    const ret_str = if (func.return_width) |w| widthToLLVMType(w) else "void";

    // function signature with parameters
    try emitter.appendFmt("define {s}{s} @{s}(", .{ cc_attr, ret_str, func.name });

    for (func.params, 0..) |param, i| {
        if (i > 0) try emitter.appendSlice(", ");
        try emitter.appendFmt("{s} %arg{d}", .{ widthToLLVMType(param.width), i });
    }

    try emitter.appendSlice(") {\n");
    try emitter.raw("entry:");

    // track SSA values: vreg -> LLVM SSA name
    var ssa_map = SsaMap{};

    // track alloca pointers keyed by fp-offset (from store_arg/store_local/load_local)
    var alloca_map = AllocaMap{};

    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &ssa_map, &alloca_map, func, globals);
    }

    try emitter.raw("}");
    try emitter.newline();
}

fn lowerInst(
    emitter: *Emitter,
    inst: MInst,
    ssa_map: *SsaMap,
    alloca_map: *AllocaMap,
    func: *const MIRFunction,
    globals: *const GlobalVars,
) !void {
    switch (inst) {
        .mov_imm => |op| {
            const ssa_name = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  %{d} = add {s} 0, {d}\n", .{ ssa_name, type_str, op.value });
        },

        .mov_reg => |op| {
            const src_ssa = ssa_map.get(op.src);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  %{d} = add {s} %{d}, 0\n", .{ dst_ssa, type_str, src_ssa });
        },

        .binop => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const op_str = binOpToLLVM(op.op);

            try emitter.appendFmt("  %{d} = {s} {s} %{d}, %{d}\n", .{
                dst_ssa, op_str, type_str, lhs_ssa, rhs_ssa,
            });
        },

        .cmp => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const cmp_op_str = cmpOpToLLVM(op.op);

            // icmp returns i1, zero-extend to target width
            try emitter.appendFmt("  %cmp{d} = icmp {s} {s} %{d}, %{d}\n", .{
                dst_ssa, cmp_op_str, type_str, lhs_ssa, rhs_ssa,
            });
            try emitter.appendFmt("  %{d} = zext i1 %cmp{d} to {s}\n", .{
                dst_ssa, dst_ssa, type_str,
            });
        },

        .ret => |op| {
            if (op.value) |vreg| {
                const src_ssa = ssa_map.get(vreg);
                const ret_type = if (func.return_width) |w| widthToLLVMType(w) else "i32";
                try emitter.appendFmt("  ret {s} %{d}\n", .{ ret_type, src_ssa });
            } else {
                if (func.return_width) |w| {
                    // non-void function with no explicit value â€” return 0
                    try emitter.appendFmt("  ret {s} 0\n", .{widthToLLVMType(w)});
                } else {
                    try emitter.appendSlice("  ret void\n");
                }
            }
        },

        .prologue, .epilogue => {
            // LLVM handles prologue/epilogue automatically
        },

        .store_arg => |op| {
            const type_str = widthToLLVMType(op.width);
            // allocate a stack slot for this parameter
            const alloca_id = alloca_map.getOrCreate(op.offset);
            try emitter.appendFmt("  %local.{d} = alloca {s}\n", .{ alloca_id, type_str });
            try emitter.appendFmt("  store {s} %arg{d}, ptr %local.{d}\n", .{ type_str, op.arg_idx, alloca_id });
        },

        .store_local => |op| {
            const src_ssa = ssa_map.get(op.src);
            const type_str = widthToLLVMType(op.width);
            const alloca_id = alloca_map.getOrCreate(op.offset);

            // emit alloca on first use of this offset
            if (!alloca_map.isEmitted(op.offset)) {
                try emitter.appendFmt("  %local.{d} = alloca {s}\n", .{ alloca_id, type_str });
                alloca_map.markEmitted(op.offset);
            }

            try emitter.appendFmt("  store {s} %{d}, ptr %local.{d}\n", .{ type_str, src_ssa, alloca_id });
        },

        .load_local => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const alloca_id = alloca_map.getOrCreate(op.offset);

            try emitter.appendFmt("  %{d} = load {s}, ptr %local.{d}\n", .{ dst_ssa, type_str, alloca_id });
        },

        .store_global => |op| {
            const src_ssa = ssa_map.get(op.src);
            const type_str = widthToLLVMType(op.width);
            const name = globals.getName(op.global_idx);

            try emitter.appendFmt("  store {s} %{d}, ptr @{s}\n", .{ type_str, src_ssa, name });
        },

        .load_global => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const name = globals.getName(op.global_idx);

            try emitter.appendFmt("  %{d} = load {s}, ptr @{s}\n", .{ dst_ssa, type_str, name });
        },

        .call => |op| {
            // build argument list
            var args_str = try std.ArrayList(u8).initCapacity(emitter.allocator, 64);
            defer args_str.deinit(emitter.allocator);

            for (op.args, 0..) |arg_vreg, i| {
                if (i > 0) try args_str.appendSlice(emitter.allocator, ", ");
                const arg_ssa = ssa_map.get(arg_vreg);
                var buf: [32]u8 = undefined;
                const arg_fmt = std.fmt.bufPrint(&buf, "i32 %{d}", .{arg_ssa}) catch unreachable;
                try args_str.appendSlice(emitter.allocator, arg_fmt);
            }

            const call_cc = ccAttr(op.call_conv);

            if (op.dst) |dst_vreg| {
                const dst_ssa = ssa_map.allocFor(dst_vreg);
                const ret_type = widthToLLVMType(op.width);
                try emitter.appendFmt("  %{d} = call {s}{s} @{s}({s})\n", .{
                    dst_ssa, call_cc, ret_type, op.func_name, args_str.items,
                });
            } else {
                try emitter.appendFmt("  call {s}void @{s}({s})\n", .{
                    call_cc, op.func_name, args_str.items,
                });
            }
        },
    }
}

fn ccAttr(cc: CallingConvention) []const u8 {
    return switch (cc) {
        .c => "",
        .honey => "fastcc ",
        else => "",
    };
}

fn widthToLLVMType(width: Width) []const u8 {
    return switch (width) {
        .w32 => "i32",
        .w64 => "i64",
    };
}

fn binOpToLLVM(op: BinOp) []const u8 {
    return switch (op) {
        .add => "add",
        .sub => "sub",
        .mul => "mul",
        .div_s => "sdiv",
        .div_u => "udiv",
        .mod_s => "srem",
        .mod_u => "urem",
        .bit_and => "and",
        .bit_or => "or",
        .bit_xor => "xor",
        .shl => "shl",
        .shr_s => "ashr",
        .shr_u => "lshr",
    };
}

fn cmpOpToLLVM(op: CmpOp) []const u8 {
    return switch (op) {
        .eq => "eq",
        .ne => "ne",
        .lt_s => "slt",
        .lt_u => "ult",
        .le_s => "sle",
        .le_u => "ule",
        .gt_s => "sgt",
        .gt_u => "ugt",
        .ge_s => "sge",
        .ge_u => "uge",
    };
}

/// Map virtual registers to LLVM SSA names.
const SsaMap = struct {
    map: [256]u16 = [_]u16{0} ** 256,
    next_ssa: u16 = 0,

    fn allocFor(self: *SsaMap, vreg: VReg) u16 {
        const ssa = self.next_ssa;
        self.next_ssa += 1;
        if (vreg < 256) {
            self.map[vreg] = ssa;
        }
        return ssa;
    }

    fn get(self: *const SsaMap, vreg: VReg) u16 {
        if (vreg < 256) {
            return self.map[vreg];
        }
        return 0;
    }
};

/// Map fp-relative offsets to alloca identifiers.
/// Tracks which allocas have been emitted to avoid duplicates.
const AllocaMap = struct {
    offsets: [64]i16 = [_]i16{0} ** 64,
    emitted: [64]bool = [_]bool{false} ** 64,
    count: u16 = 0,

    fn getOrCreate(self: *AllocaMap, offset: i16) u16 {
        // check if offset already mapped
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) return @intCast(i);
        }
        // new offset
        const id = self.count;
        self.offsets[id] = offset;
        self.count += 1;
        return id;
    }

    fn isEmitted(self: *const AllocaMap, offset: i16) bool {
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) return self.emitted[i];
        }
        return false;
    }

    fn markEmitted(self: *AllocaMap, offset: i16) void {
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) {
                self.emitted[i] = true;
                return;
            }
        }
    }
};

/// LLVM IR text emitter.
const Emitter = struct {
    allocator: mem.Allocator,
    buffer: std.ArrayList(u8),
    target: Target,

    fn init(allocator: mem.Allocator, target: Target) !Emitter {
        return .{
            .allocator = allocator,
            .buffer = try std.ArrayList(u8).initCapacity(allocator, 4096),
            .target = target,
        };
    }

    fn deinit(self: *Emitter) void {
        self.buffer.deinit(self.allocator);
    }

    fn getOutput(self: *const Emitter) []const u8 {
        return self.buffer.items;
    }

    fn raw(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn comment(self: *Emitter, msg: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, "; ");
        try self.buffer.appendSlice(self.allocator, msg);
        try self.buffer.append(self.allocator, '\n');
    }

    fn newline(self: *Emitter) !void {
        try self.buffer.append(self.allocator, '\n');
    }

    fn appendSlice(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn appendFmt(self: *Emitter, comptime fmt: []const u8, args: anytype) !void {
        var buf: [512]u8 = undefined;
        const text = std.fmt.bufPrint(&buf, fmt, args) catch return error.OutOfMemory;
        try self.buffer.appendSlice(self.allocator, text);
    }
};
