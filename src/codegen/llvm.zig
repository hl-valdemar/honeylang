const std = @import("std");
const mem = std.mem;

const mir = @import("mir.zig");
const MIRModule = mir.MIRModule;
const MIRFunction = mir.MIRFunction;
const MInst = mir.MInst;
const VReg = mir.VReg;
const Width = mir.Width;
const BinOp = mir.BinOp;
const CmpOp = mir.CmpOp;
const GlobalVars = mir.GlobalVars;

const codegen = @import("codegen.zig");
const Target = codegen.Target;

const CallingConvention = @import("../parser/ast.zig").CallingConvention;
const types_mod = @import("../semantic/types.zig");
const TypeRegistry = types_mod.TypeRegistry;
const TypeId = types_mod.TypeId;

/// Lower MIR module to LLVM IR text format.
pub fn lower(allocator: mem.Allocator, module: *const MIRModule, types: *const TypeRegistry, target: Target) ![]const u8 {
    var emitter = try Emitter.init(allocator, target);
    defer emitter.deinit();

    // module header
    try emitter.comment("Generated by the Honey compiler");
    try emitter.raw("source_filename = \"honey\"");
    try emitter.appendFmt("target triple = \"{s}\"\n", .{target.getLLVMTriple()});
    try emitter.newline();

    // emit struct type definitions
    try emitStructTypes(&emitter, types);

    // emit slice type definition if any slice types are registered
    if (types.slice_types.items.len > 0 or hasSliceParams(module)) {
        try emitter.appendFmt("%slice = type {{ ptr, {s} }}", .{emitter.target.ptrLLVMType()});
        try emitter.newline();
    }

    // emit memcpy intrinsic if any struct types have struct fields
    if (needsMemcpy(types)) {
        const ptr_t = emitter.target.ptrLLVMType();
        try emitter.appendFmt("declare void @llvm.memcpy.p0.p0.{s}(ptr, ptr, {s}, i1)", .{ ptr_t, ptr_t });
        try emitter.newline();
    }

    // emit trap intrinsic if any function contains a trap instruction
    const needs_trap = needsTrap(module) or !hasMain(module);
    if (needs_trap) {
        try emitter.raw("declare void @llvm.trap() noreturn nounwind");
        try emitter.newline();
    }

    // emit global variable declarations
    try emitGlobals(&emitter, &module.globals, types);

    // emit extern function declarations
    for (module.extern_functions.items) |ext| {
        try emitExternDecl(&emitter, &ext, types);
    }
    if (module.extern_functions.items.len > 0) {
        try emitter.newline();
    }

    // emit function definitions
    for (module.functions.items) |*func| {
        try lowerFunction(&emitter, func, &module.globals, types);
    }

    // emit trap stub if no main function was defined
    if (!hasMain(module)) {
        try emitter.raw("define i32 @main() {");
        try emitter.raw("entry:");
        try emitter.raw("  call void @llvm.trap()");
        try emitter.raw("  unreachable");
        try emitter.raw("}");
        try emitter.newline();
    }

    // register __honey_init as a global constructor so it runs before main
    try emitter.raw("@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__honey_init, ptr null }]");
    try emitter.newline();

    return try allocator.dupe(u8, emitter.getOutput());
}

fn emitStructTypes(emitter: *Emitter, types: *const TypeRegistry) !void {
    for (types.struct_types.items) |st| {
        try emitter.appendFmt("%{s} = type {{ ", .{st.name});
        for (st.fields, 0..) |field, i| {
            if (i > 0) try emitter.appendSlice(", ");
            if (field.type_id.isStruct()) {
                const inner = types.struct_types.items[field.type_id.struct_type];
                try emitter.appendFmt("%{s}", .{inner.name});
            } else {
                try emitter.appendSlice(typeIdToLLVMType(field.type_id, emitter.target));
            }
        }
        try emitter.appendSlice(" }\n");
    }
    if (types.struct_types.items.len > 0) {
        try emitter.newline();
    }
}

fn needsMemcpy(types: *const TypeRegistry) bool {
    return types.struct_types.items.len > 0;
}

fn hasSliceParams(module: *const MIRModule) bool {
    for (module.functions.items) |*func| {
        for (func.params) |param| {
            if (param.is_slice) return true;
        }
    }
    for (module.extern_functions.items) |ext| {
        for (ext.param_slice_flags) |is_slice| {
            if (is_slice) return true;
        }
    }
    return false;
}

fn needsTrap(module: *const MIRModule) bool {
    for (module.functions.items) |*func| {
        for (func.instructions.items) |inst| {
            if (inst == .trap) return true;
        }
    }
    return false;
}

fn hasMain(module: *const MIRModule) bool {
    for (module.functions.items) |*func| {
        if (std.mem.eql(u8, func.name, "main")) return true;
    }
    return false;
}

fn emitGlobals(emitter: *Emitter, globals: *const GlobalVars, types: *const TypeRegistry) !void {
    for (0..globals.count()) |i| {
        const idx: mir.GlobalIndex = @intCast(i);
        const name = globals.getName(idx);
        const type_id = globals.getTypeId(idx);
        const is_const = globals.getIsConst(idx);
        const linkage = if (is_const) "constant" else "global";

        if (type_id.isStruct()) {
            const struct_type = types.struct_types.items[type_id.struct_type];
            if (globals.getStructInit(idx)) |field_values| {
                // Static initializer: @P = constant/global %Point { i32 42, i32 54 }
                try emitter.appendFmt("@{s} = {s} %{s} {{ ", .{ name, linkage, struct_type.name });
                for (struct_type.fields, 0..) |field, fi| {
                    if (fi > 0) try emitter.appendSlice(", ");
                    const field_llvm = typeIdToLLVMType(field.type_id, emitter.target);
                    if (isFloatType(field.type_id)) {
                        // Emit IEEE 754 double-precision hex (LLVM format for float constants)
                        const bits: u64 = @bitCast(field_values[fi]);
                        try emitter.appendFmt("{s} 0x{X:0>16}", .{ field_llvm, bits });
                    } else {
                        try emitter.appendFmt("{s} {d}", .{ field_llvm, field_values[fi] });
                    }
                }
                try emitter.appendSlice(" }\n");
            } else {
                // Runtime-initialized struct
                try emitter.appendFmt("@{s} = {s} %{s} zeroinitializer\n", .{ name, linkage, struct_type.name });
            }
        } else if (type_id.isArray()) {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[type_id.array];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            if (globals.getArrayInit(idx)) |elem_values| {
                // Static initializer: @arr = global [3 x i32] [i32 1, i32 2, i32 3]
                try emitter.appendFmt("@{s} = {s} [{d} x {s}] [", .{ name, linkage, arr_info.length, elem_llvm });
                for (0..arr_info.length) |ei| {
                    if (ei > 0) try emitter.appendSlice(", ");
                    if (isFloatType(arr_info.element_type)) {
                        const bits: u64 = @bitCast(elem_values[ei]);
                        try emitter.appendFmt("{s} 0x{X:0>16}", .{ elem_llvm, bits });
                    } else {
                        try emitter.appendFmt("{s} {d}", .{ elem_llvm, elem_values[ei] });
                    }
                }
                try emitter.appendSlice("]\n");
            } else {
                // Runtime-initialized array
                try emitter.appendFmt("@{s} = {s} [{d} x {s}] zeroinitializer\n", .{ name, linkage, arr_info.length, elem_llvm });
            }
        } else if (type_id.isSlice()) {
            const usize_t = emitter.target.ptrLLVMType();
            try emitter.appendFmt("@{s} = {s} {{ ptr, {s} }} zeroinitializer\n", .{ name, linkage, usize_t });
        } else if (globals.getStringInit(idx)) |bytes| {
            // String constant: @str.0 = private constant [5 x i8] [i8 104, i8 101, ...]
            try emitter.appendFmt("@{s} = private constant [{d} x i8] [", .{ name, bytes.len });
            for (bytes, 0..) |byte, bi| {
                if (bi > 0) try emitter.appendSlice(", ");
                try emitter.appendFmt("i8 {d}", .{byte});
            }
            try emitter.appendSlice("]\n");
        } else {
            const width = globals.getWidth(idx);
            const type_str = widthToLLVMType(width);
            const init_value = globals.getInitValue(idx);

            if (init_value) |val| {
                if (width.isFloat()) {
                    const bits: u64 = @bitCast(val);
                    try emitter.appendFmt("@{s} = {s} {s} 0x{X:0>16}\n", .{ name, linkage, type_str, bits });
                } else {
                    try emitter.appendFmt("@{s} = {s} {s} {d}\n", .{ name, linkage, type_str, val });
                }
            } else {
                if (width.isFloat()) {
                    try emitter.appendFmt("@{s} = {s} {s} 0.0\n", .{ name, linkage, type_str });
                } else {
                    try emitter.appendFmt("@{s} = {s} {s} 0\n", .{ name, linkage, type_str });
                }
            }
        }
    }
    if (globals.count() > 0) {
        try emitter.newline();
    }
}

fn emitExternDecl(emitter: *Emitter, ext: *const mir.ExternFunc, types: *const TypeRegistry) !void {
    const cc_attr = ccAttr(ext.call_conv);
    const ret_str = if (ext.return_width) |w| widthToLLVMType(w) else "void";

    try emitter.appendFmt("declare {s}{s} @{s}(", .{ cc_attr, ret_str, ext.name });

    for (ext.param_widths, 0..) |pw, j| {
        if (j > 0) try emitter.appendSlice(", ");
        if (j < ext.param_struct_indices.len) {
            if (ext.param_struct_indices[j]) |si| {
                const struct_type = types.struct_types.items[si];
                switch (structParamABI(struct_type.size, emitter.target.arch)) {
                    .register => try emitter.appendSlice(structCoercionType(struct_type.size, emitter.target.arch)),
                    .two_registers => try emitter.appendSlice("[2 x i64]"),
                    .indirect => try emitter.appendFmt("ptr byval(%{s})", .{struct_type.name}),
                }
                continue;
            }
        }
        if (j < ext.param_slice_flags.len and ext.param_slice_flags[j]) {
            try emitter.appendSlice("ptr byval(%slice)");
            continue;
        }
        try emitter.appendSlice(widthToLLVMType(pw));
    }

    if (ext.is_variadic) {
        if (ext.param_widths.len > 0) try emitter.appendSlice(", ");
        try emitter.appendSlice("...");
    }

    try emitter.appendSlice(")\n");
}

fn lowerFunction(emitter: *Emitter, func: *const MIRFunction, globals: *const GlobalVars, types: *const TypeRegistry) !void {
    const cc_attr = ccAttr(func.call_conv);

    if (func.sret_struct_idx) |struct_idx| {
        // sret function: returns void, first param is hidden sret pointer
        const struct_type = types.struct_types.items[struct_idx];
        try emitter.appendFmt("define {s}void @{s}(ptr sret(%{s}) %arg0", .{
            cc_attr, func.name, struct_type.name,
        });
        // remaining params shifted by 1
        for (func.params, 0..) |param, i| {
            if (param.struct_idx) |si| {
                const param_struct = types.struct_types.items[si];
                try emitter.appendFmt(", ptr byval(%{s}) %arg{d}", .{ param_struct.name, i + 1 });
            } else if (param.is_slice) {
                try emitter.appendFmt(", ptr byval(%slice) %arg{d}", .{i + 1});
            } else {
                try emitter.appendFmt(", {s} %arg{d}", .{ widthToLLVMType(param.width), i + 1 });
            }
        }
        try emitter.appendSlice(") {\n");
    } else {
        const is_main = std.mem.eql(u8, func.name, "main");
        // main always returns i32 for the OS, even if declared void
        const ret_str = if (is_main and func.return_width == null) "i32" else if (func.return_width) |w| widthToLLVMType(w) else "void";

        // function signature with parameters
        try emitter.appendFmt("define {s}{s} @{s}(", .{ cc_attr, ret_str, func.name });

        for (func.params, 0..) |param, i| {
            if (i > 0) try emitter.appendSlice(", ");
            if (param.struct_idx) |si| {
                const struct_type = types.struct_types.items[si];
                try emitter.appendFmt("ptr byval(%{s}) %arg{d}", .{ struct_type.name, i });
            } else if (param.is_slice) {
                try emitter.appendFmt("ptr byval(%slice) %arg{d}", .{i});
            } else {
                try emitter.appendFmt("{s} %arg{d}", .{ widthToLLVMType(param.width), i });
            }
        }

        try emitter.appendSlice(") {\n");
    }
    try emitter.raw("entry:");

    // track SSA values: vreg -> LLVM SSA name
    var ssa_map = SsaMap{};

    // track alloca pointers keyed by fp-offset (from store_arg/store_local/load_local)
    var alloca_map = AllocaMap{};

    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &ssa_map, &alloca_map, func, globals, types);
    }

    // If the last instruction is not a terminator, add an implicit return
    // to keep LLVM happy (e.g. a label at the end with no further code).
    const last = func.instructions.items[func.instructions.items.len - 1];
    const needs_ret = switch (last) {
        .ret, .br, .br_cond, .trap => false,
        else => true,
    };
    if (needs_ret) {
        const is_main = std.mem.eql(u8, func.name, "main");
        if (is_main and func.return_width == null) {
            // void main returns i32 0 to the OS
            try emitter.appendSlice("  ret i32 0\n");
        } else if (func.return_width) |w| {
            const zero_str: []const u8 = if (w.isFloat()) "0.0" else "0";
            try emitter.appendFmt("  ret {s} {s}\n", .{ widthToLLVMType(w), zero_str });
        } else {
            try emitter.appendSlice("  ret void\n");
        }
    }

    try emitter.raw("}");
    try emitter.newline();
}

fn lowerInst(
    emitter: *Emitter,
    inst: MInst,
    ssa_map: *SsaMap,
    alloca_map: *AllocaMap,
    func: *const MIRFunction,
    globals: *const GlobalVars,
    types: *const TypeRegistry,
) !void {
    switch (inst) {
        .mov_imm => |op| {
            const ssa_name = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            if (op.width.isFloat()) {
                // Float immediate: value holds IEEE 754 bits, emit as LLVM hex float.
                // LLVM requires all hex float constants in 64-bit (double) format,
                // even for float types. Convert f32 bits to f64 bits.
                const bits: u64 = if (op.width == .wf32) blk: {
                    const f32_bits: u32 = @truncate(@as(u64, @bitCast(op.value)));
                    const f32_val: f32 = @bitCast(f32_bits);
                    const f64_val: f64 = @floatCast(f32_val);
                    break :blk @bitCast(f64_val);
                } else @bitCast(op.value);
                try emitter.appendFmt("  %{d} = fadd {s} 0.0, 0x{X:0>16}\n", .{ ssa_name, type_str, bits });
            } else {
                try emitter.appendFmt("  %{d} = add {s} 0, {d}\n", .{ ssa_name, type_str, op.value });
            }
        },

        .mov_reg => |op| {
            const src_ssa = ssa_map.get(op.src);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            if (op.width.isFloat()) {
                try emitter.appendFmt("  %{d} = fadd {s} %{d}, 0.0\n", .{ dst_ssa, type_str, src_ssa });
            } else {
                try emitter.appendFmt("  %{d} = add {s} %{d}, 0\n", .{ dst_ssa, type_str, src_ssa });
            }
        },

        .binop => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const op_str = if (op.width.isFloat()) floatBinOpToLLVM(op.op) else binOpToLLVM(op.op);

            try emitter.appendFmt("  %{d} = {s} {s} %{d}, %{d}\n", .{
                dst_ssa, op_str, type_str, lhs_ssa, rhs_ssa,
            });
        },

        .cmp => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);

            if (op.width.isFloat()) {
                const fcmp_op_str = floatCmpOpToLLVM(op.op);
                // fcmp returns i1, zero-extend to i8 (bool)
                try emitter.appendFmt("  %cmp{d} = fcmp {s} {s} %{d}, %{d}\n", .{
                    dst_ssa, fcmp_op_str, type_str, lhs_ssa, rhs_ssa,
                });
                try emitter.appendFmt("  %{d} = zext i1 %cmp{d} to i8\n", .{
                    dst_ssa, dst_ssa,
                });
            } else {
                const cmp_op_str = cmpOpToLLVM(op.op);
                // icmp returns i1, zero-extend to i8 (bool)
                try emitter.appendFmt("  %cmp{d} = icmp {s} {s} %{d}, %{d}\n", .{
                    dst_ssa, cmp_op_str, type_str, lhs_ssa, rhs_ssa,
                });
                try emitter.appendFmt("  %{d} = zext i1 %cmp{d} to i8\n", .{
                    dst_ssa, dst_ssa,
                });
            }
        },

        .ret => |op| {
            const is_main = std.mem.eql(u8, func.name, "main");
            if (op.value) |vreg| {
                const src_ssa = ssa_map.get(vreg);
                const ret_type = if (func.return_width) |w| widthToLLVMType(w) else "i32";
                try emitter.appendFmt("  ret {s} %{d}\n", .{ ret_type, src_ssa });
            } else {
                if (is_main and func.return_width == null) {
                    // void main returns i32 0 to the OS
                    try emitter.appendSlice("  ret i32 0\n");
                } else if (func.return_width) |w| {
                    // non-void function with no explicit value — return 0
                    const zero_str: []const u8 = if (w.isFloat()) "0.0" else "0";
                    try emitter.appendFmt("  ret {s} {s}\n", .{ widthToLLVMType(w), zero_str });
                } else {
                    try emitter.appendSlice("  ret void\n");
                }
            }
        },

        .prologue, .epilogue => {
            // LLVM handles prologue/epilogue automatically
        },

        .trap => {
            try emitter.appendSlice("  call void @llvm.trap()\n");
            try emitter.appendSlice("  unreachable\n");
            // Start a new basic block after unreachable — LLVM requires every
            // basic block to have a terminator, so add unreachable here too.
            const dead_label = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("dead.{d}:\n  unreachable\n", .{dead_label});
        },

        .store_arg => |op| {
            const type_str = widthToLLVMType(op.width);
            // allocate a stack slot for this parameter
            const alloca_id = alloca_map.getOrCreate(op.offset);
            try emitter.appendFmt("  %local.{d} = alloca {s}\n", .{ alloca_id, type_str });
            try emitter.appendFmt("  store {s} %arg{d}, ptr %local.{d}\n", .{ type_str, op.arg_idx, alloca_id });
        },

        .store_local => |op| {
            const src_ssa = ssa_map.get(op.src);
            const type_str = widthToLLVMType(op.width);
            const alloca_id = alloca_map.getOrCreate(op.offset);

            // emit alloca on first use of this offset
            if (!alloca_map.isEmitted(op.offset)) {
                try emitter.appendFmt("  %local.{d} = alloca {s}\n", .{ alloca_id, type_str });
                alloca_map.markEmitted(op.offset);
            }

            try emitter.appendFmt("  store {s} %{d}, ptr %local.{d}\n", .{ type_str, src_ssa, alloca_id });
        },

        .load_local => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const alloca_id = alloca_map.getOrCreate(op.offset);

            try emitter.appendFmt("  %{d} = load {s}, ptr %local.{d}\n", .{ dst_ssa, type_str, alloca_id });
        },

        .store_global => |op| {
            const src_ssa = ssa_map.get(op.src);
            const type_str = widthToLLVMType(op.width);
            const name = globals.getName(op.global_idx);

            try emitter.appendFmt("  store {s} %{d}, ptr @{s}\n", .{ type_str, src_ssa, name });
        },

        .load_global => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const name = globals.getName(op.global_idx);

            try emitter.appendFmt("  %{d} = load {s}, ptr @{s}\n", .{ dst_ssa, type_str, name });
        },

        .label => |id| {
            try emitter.appendFmt("lbl.{d}:\n", .{id});
        },

        .br_cond => |op| {
            const cond_ssa = ssa_map.get(op.cond);
            const cond_type = widthToLLVMType(op.cond_width);
            // convert condition to i1 for LLVM br
            const cmp_id = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %cond.{d} = icmp ne {s} %{d}, 0\n", .{ cmp_id, cond_type, cond_ssa });
            try emitter.appendFmt("  br i1 %cond.{d}, label %lbl.{d}, label %lbl.{d}\n", .{
                cmp_id, op.true_label, op.false_label,
            });
        },

        .br => |target| {
            try emitter.appendFmt("  br label %lbl.{d}\n", .{target});
        },

        .call => |op| {
            std.debug.assert(op.args.len == op.arg_widths.len);
            const call_cc = ccAttr(op.call_conv);

            if (op.sret_struct_idx) |struct_idx| {
                // sret call: first arg gets sret attribute, call returns void
                const struct_type = types.struct_types.items[struct_idx];
                var args_str = try std.ArrayList(u8).initCapacity(emitter.allocator, 128);
                defer args_str.deinit(emitter.allocator);

                // first arg: sret pointer
                const first_ssa = ssa_map.get(op.args[0]);
                var buf: [64]u8 = undefined;
                const sret_fmt = std.fmt.bufPrint(&buf, "ptr sret(%{s}) %{d}", .{
                    struct_type.name, first_ssa,
                }) catch unreachable;
                try args_str.appendSlice(emitter.allocator, sret_fmt);

                // remaining args
                for (op.args[1..], op.arg_widths[1..], 1..) |arg_vreg, arg_width, i| {
                    try args_str.appendSlice(emitter.allocator, ", ");
                    const arg_ssa = ssa_map.get(arg_vreg);

                    const struct_idx_val: ?u32 = if (i < op.arg_struct_indices.len) op.arg_struct_indices[i] else null;
                    const is_slice_arg = if (i < op.arg_slice_flags.len) op.arg_slice_flags[i] else false;
                    if (struct_idx_val) |si| {
                        const arg_struct = types.struct_types.items[si];
                        switch (structParamABI(arg_struct.size, emitter.target.arch)) {
                            .register => {
                                const coerce_type = structCoercionType(arg_struct.size, emitter.target.arch);
                                const load_ssa = ssa_map.next_ssa;
                                ssa_map.next_ssa += 1;
                                try emitter.appendFmt("  %{d} = load {s}, ptr %{d}\n", .{ load_ssa, coerce_type, arg_ssa });
                                var abuf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&abuf, "{s} %{d}", .{ coerce_type, load_ssa }) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                            .two_registers => {
                                const load_ssa = ssa_map.next_ssa;
                                ssa_map.next_ssa += 1;
                                try emitter.appendFmt("  %{d} = load [2 x i64], ptr %{d}\n", .{ load_ssa, arg_ssa });
                                var abuf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&abuf, "[2 x i64] %{d}", .{load_ssa}) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                            .indirect => {
                                var abuf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&abuf, "ptr byval(%{s}) %{d}", .{ arg_struct.name, arg_ssa }) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                        }
                    } else if (is_slice_arg) {
                        var abuf: [64]u8 = undefined;
                        const arg_fmt = std.fmt.bufPrint(&abuf, "ptr byval(%slice) %{d}", .{arg_ssa}) catch unreachable;
                        try args_str.appendSlice(emitter.allocator, arg_fmt);
                    } else {
                        const arg_type = widthToLLVMType(arg_width);
                        var abuf: [32]u8 = undefined;
                        const arg_fmt = std.fmt.bufPrint(&abuf, "{s} %{d}", .{ arg_type, arg_ssa }) catch unreachable;
                        try args_str.appendSlice(emitter.allocator, arg_fmt);
                    }
                }

                try emitter.appendFmt("  call {s}void @{s}({s})\n", .{
                    call_cc, op.func_name, args_str.items,
                });
            } else {
                // normal call
                var args_str = try std.ArrayList(u8).initCapacity(emitter.allocator, 64);
                defer args_str.deinit(emitter.allocator);

                for (op.args, op.arg_widths, 0..) |arg_vreg, arg_width, i| {
                    if (i > 0) try args_str.appendSlice(emitter.allocator, ", ");
                    const arg_ssa = ssa_map.get(arg_vreg);

                    // check if this arg is a byval struct or slice
                    const struct_idx: ?u32 = if (i < op.arg_struct_indices.len) op.arg_struct_indices[i] else null;
                    const is_slice_arg = if (i < op.arg_slice_flags.len) op.arg_slice_flags[i] else false;
                    if (struct_idx) |si| {
                        const arg_struct = types.struct_types.items[si];
                        switch (structParamABI(arg_struct.size, emitter.target.arch)) {
                            .register => {
                                const coerce_type = structCoercionType(arg_struct.size, emitter.target.arch);
                                const load_ssa = ssa_map.next_ssa;
                                ssa_map.next_ssa += 1;
                                try emitter.appendFmt("  %{d} = load {s}, ptr %{d}\n", .{ load_ssa, coerce_type, arg_ssa });
                                var buf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&buf, "{s} %{d}", .{ coerce_type, load_ssa }) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                            .two_registers => {
                                const load_ssa = ssa_map.next_ssa;
                                ssa_map.next_ssa += 1;
                                try emitter.appendFmt("  %{d} = load [2 x i64], ptr %{d}\n", .{ load_ssa, arg_ssa });
                                var buf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&buf, "[2 x i64] %{d}", .{load_ssa}) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                            .indirect => {
                                var buf: [64]u8 = undefined;
                                const arg_fmt = std.fmt.bufPrint(&buf, "ptr byval(%{s}) %{d}", .{ arg_struct.name, arg_ssa }) catch unreachable;
                                try args_str.appendSlice(emitter.allocator, arg_fmt);
                            },
                        }
                    } else if (is_slice_arg) {
                        var buf: [64]u8 = undefined;
                        const arg_fmt = std.fmt.bufPrint(&buf, "ptr byval(%slice) %{d}", .{arg_ssa}) catch unreachable;
                        try args_str.appendSlice(emitter.allocator, arg_fmt);
                    } else {
                        const arg_type = widthToLLVMType(arg_width);
                        var buf: [32]u8 = undefined;
                        const arg_fmt = std.fmt.bufPrint(&buf, "{s} %{d}", .{ arg_type, arg_ssa }) catch unreachable;
                        try args_str.appendSlice(emitter.allocator, arg_fmt);
                    }
                }

                if (op.dst) |dst_vreg| {
                    const dst_ssa = ssa_map.allocFor(dst_vreg);
                    const ret_type = widthToLLVMType(op.width);
                    if (op.is_variadic) {
                        // Variadic calls need explicit function type: call i32 (ptr, ...) @name(args)
                        var type_str = try std.ArrayList(u8).initCapacity(emitter.allocator, 64);
                        defer type_str.deinit(emitter.allocator);
                        try type_str.appendSlice(emitter.allocator, ret_type);
                        try type_str.appendSlice(emitter.allocator, " (");
                        for (0..op.fixed_param_count) |pi| {
                            if (pi > 0) try type_str.appendSlice(emitter.allocator, ", ");
                            try type_str.appendSlice(emitter.allocator, widthToLLVMType(op.arg_widths[pi]));
                        }
                        if (op.fixed_param_count > 0) try type_str.appendSlice(emitter.allocator, ", ");
                        try type_str.appendSlice(emitter.allocator, "...)");
                        try emitter.appendFmt("  %{d} = call {s}{s} @{s}({s})\n", .{
                            dst_ssa, call_cc, type_str.items, op.func_name, args_str.items,
                        });
                    } else {
                        try emitter.appendFmt("  %{d} = call {s}{s} @{s}({s})\n", .{
                            dst_ssa, call_cc, ret_type, op.func_name, args_str.items,
                        });
                    }
                } else {
                    if (op.is_variadic) {
                        var type_str = try std.ArrayList(u8).initCapacity(emitter.allocator, 64);
                        defer type_str.deinit(emitter.allocator);
                        try type_str.appendSlice(emitter.allocator, "void (");
                        for (0..op.fixed_param_count) |pi| {
                            if (pi > 0) try type_str.appendSlice(emitter.allocator, ", ");
                            try type_str.appendSlice(emitter.allocator, widthToLLVMType(op.arg_widths[pi]));
                        }
                        if (op.fixed_param_count > 0) try type_str.appendSlice(emitter.allocator, ", ");
                        try type_str.appendSlice(emitter.allocator, "...)");
                        try emitter.appendFmt("  call {s}{s} @{s}({s})\n", .{
                            call_cc, type_str.items, op.func_name, args_str.items,
                        });
                    } else {
                        try emitter.appendFmt("  call {s}void @{s}({s})\n", .{
                            call_cc, op.func_name, args_str.items,
                        });
                    }
                }
            }
        },

        .load_field => |op| {
            const base_ssa = ssa_map.get(op.base);
            const struct_type = types.struct_types.items[op.struct_idx];
            const field_type_id = struct_type.fields[op.field_idx].type_id;

            if (field_type_id.isStruct()) {
                // struct field: GEP only — the pointer to the embedded struct IS the value
                const dst_ssa = ssa_map.allocFor(op.dst);
                try emitter.appendFmt("  %{d} = getelementptr inbounds %{s}, ptr %{d}, i32 0, i32 {d}\n", .{
                    dst_ssa, struct_type.name, base_ssa, op.field_idx,
                });
            } else {
                // primitive field: GEP + load
                const gep_ssa = ssa_map.next_ssa;
                ssa_map.next_ssa += 1;
                try emitter.appendFmt("  %gep.{d} = getelementptr inbounds %{s}, ptr %{d}, i32 0, i32 {d}\n", .{
                    gep_ssa, struct_type.name, base_ssa, op.field_idx,
                });

                const dst_ssa = ssa_map.allocFor(op.dst);
                try emitter.appendFmt("  %{d} = load {s}, ptr %gep.{d}\n", .{
                    dst_ssa, widthToLLVMType(op.width), gep_ssa,
                });
            }
        },

        .alloca_struct => |op| {
            const struct_type = types.struct_types.items[op.struct_idx];
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = alloca %{s}\n", .{ dst_ssa, struct_type.name });
        },

        .store_field => |op| {
            const base_ssa = ssa_map.get(op.base);
            const value_ssa = ssa_map.get(op.value);
            const struct_type = types.struct_types.items[op.struct_idx];
            const field_type_id = struct_type.fields[op.field_idx].type_id;

            // emit GEP to get pointer to field
            const gep_ssa = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds %{s}, ptr %{d}, i32 0, i32 {d}\n", .{
                gep_ssa, struct_type.name, base_ssa, op.field_idx,
            });

            if (field_type_id.isStruct()) {
                // struct field: memcpy the inline data
                const inner = types.struct_types.items[field_type_id.struct_type];
                const mcpy_t = emitter.target.ptrLLVMType();
                try emitter.appendFmt("  call void @llvm.memcpy.p0.p0.{s}(ptr %gep.{d}, ptr %{d}, {s} {d}, i1 false)\n", .{
                    mcpy_t, gep_ssa, value_ssa, mcpy_t, inner.size,
                });
            } else {
                // primitive field: direct store
                try emitter.appendFmt("  store {s} %{d}, ptr %gep.{d}\n", .{
                    widthToLLVMType(op.width), value_ssa, gep_ssa,
                });
            }
        },
        .copy_struct => |op| {
            const dst_ssa = ssa_map.get(op.dst);
            const src_ssa = ssa_map.get(op.src);
            const struct_type = types.struct_types.items[op.struct_idx];
            const mcpy_t = emitter.target.ptrLLVMType();
            try emitter.appendFmt("  call void @llvm.memcpy.p0.p0.{s}(ptr %{d}, ptr %{d}, {s} {d}, i1 false)\n", .{
                mcpy_t, dst_ssa, src_ssa, mcpy_t, struct_type.size,
            });
        },

        .addr_of_local => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const alloca_id = alloca_map.getOrCreate(op.offset);
            try emitter.appendFmt("  %{d} = getelementptr i8, ptr %local.{d}, i32 0\n", .{ dst_ssa, alloca_id });
        },

        .addr_of_global => |op| {
            const dst_ssa = ssa_map.allocFor(op.dst);
            const name = globals.getName(op.global_idx);
            try emitter.appendFmt("  %{d} = getelementptr i8, ptr @{s}, i32 0\n", .{ dst_ssa, name });
        },

        .load_ptr => |op| {
            const ptr_ssa = ssa_map.get(op.ptr);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  %{d} = load {s}, ptr %{d}\n", .{ dst_ssa, type_str, ptr_ssa });
        },

        .store_ptr => |op| {
            const ptr_ssa = ssa_map.get(op.ptr);
            const value_ssa = ssa_map.get(op.value);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  store {s} %{d}, ptr %{d}\n", .{ type_str, value_ssa, ptr_ssa });
        },

        .addr_of_field => |op| {
            const base_ssa = ssa_map.get(op.base);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const struct_type = types.struct_types.items[op.struct_idx];
            try emitter.appendFmt("  %{d} = getelementptr inbounds %{s}, ptr %{d}, i32 0, i32 {d}\n", .{
                dst_ssa, struct_type.name, base_ssa, op.field_idx,
            });
        },

        .alloca_array => |op| {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[op.array_idx];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = alloca [{d} x {s}]\n", .{ dst_ssa, arr_info.length, elem_llvm });
        },

        .alloca_array_local => |op| {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[op.array_idx];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            const alloca_id = alloca_map.getOrCreate(op.offset);
            try emitter.appendFmt("  %local.{d} = alloca [{d} x {s}]\n", .{ alloca_id, arr_info.length, elem_llvm });
            alloca_map.markEmitted(op.offset);
        },

        .load_element => |op| {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[op.array_idx];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            const usize_t = emitter.target.ptrLLVMType();
            const base_ssa = ssa_map.get(op.base);
            const index_ssa = ssa_map.get(op.index);

            // GEP to element
            const gep_ssa = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds [{d} x {s}], ptr %{d}, {s} 0, {s} %{d}\n", .{
                gep_ssa, arr_info.length, elem_llvm, base_ssa, usize_t, usize_t, index_ssa,
            });

            // load element
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = load {s}, ptr %gep.{d}\n", .{
                dst_ssa, widthToLLVMType(op.width), gep_ssa,
            });
        },

        .store_element => |op| {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[op.array_idx];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            const usize_t = emitter.target.ptrLLVMType();
            const base_ssa = ssa_map.get(op.base);
            const index_ssa = ssa_map.get(op.index);
            const value_ssa = ssa_map.get(op.value);

            // GEP to element
            const gep_ssa = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds [{d} x {s}], ptr %{d}, {s} 0, {s} %{d}\n", .{
                gep_ssa, arr_info.length, elem_llvm, base_ssa, usize_t, usize_t, index_ssa,
            });

            // store element
            try emitter.appendFmt("  store {s} %{d}, ptr %gep.{d}\n", .{
                widthToLLVMType(op.width), value_ssa, gep_ssa,
            });
        },

        .addr_of_element => |op| {
            var buf: [64]u8 = undefined;
            const arr_info = types.array_types.items[op.array_idx];
            const elem_llvm = arrayElemLLVMType(&buf, arr_info.element_type, types, emitter.target);
            const usize_t = emitter.target.ptrLLVMType();
            const base_ssa = ssa_map.get(op.base);
            const index_ssa = ssa_map.get(op.index);

            // GEP to element — the pointer IS the value for struct elements
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = getelementptr inbounds [{d} x {s}], ptr %{d}, {s} 0, {s} %{d}\n", .{
                dst_ssa, arr_info.length, elem_llvm, base_ssa, usize_t, usize_t, index_ssa,
            });
        },

        .alloca_slice_local => |op| {
            const usize_t = emitter.target.ptrLLVMType();
            const alloca_id = alloca_map.getOrCreate(op.offset);
            try emitter.appendFmt("  %local.{d} = alloca {{ ptr, {s} }}\n", .{ alloca_id, usize_t });
            alloca_map.markEmitted(op.offset);
        },

        .slice_get_ptr => |op| {
            const usize_t = emitter.target.ptrLLVMType();
            const base_ssa = ssa_map.get(op.base);
            const gep_ssa = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds {{ ptr, {s} }}, ptr %{d}, i32 0, i32 0\n", .{ gep_ssa, usize_t, base_ssa });
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = load ptr, ptr %gep.{d}\n", .{ dst_ssa, gep_ssa });
        },

        .slice_get_len => |op| {
            const usize_t = emitter.target.ptrLLVMType();
            const base_ssa = ssa_map.get(op.base);
            const gep_ssa = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds {{ ptr, {s} }}, ptr %{d}, i32 0, i32 1\n", .{ gep_ssa, usize_t, base_ssa });
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = load {s}, ptr %gep.{d}\n", .{ dst_ssa, usize_t, gep_ssa });
        },

        .make_slice => |op| {
            const usize_t = emitter.target.ptrLLVMType();
            const dst_ssa = ssa_map.get(op.dst);
            const ptr_ssa = ssa_map.get(op.ptr_val);
            const len_ssa = ssa_map.get(op.len_val);
            // store ptr field
            const ptr_gep = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds {{ ptr, {s} }}, ptr %{d}, i32 0, i32 0\n", .{ ptr_gep, usize_t, dst_ssa });
            try emitter.appendFmt("  store ptr %{d}, ptr %gep.{d}\n", .{ ptr_ssa, ptr_gep });
            // store len field
            const len_gep = ssa_map.next_ssa;
            ssa_map.next_ssa += 1;
            try emitter.appendFmt("  %gep.{d} = getelementptr inbounds {{ ptr, {s} }}, ptr %{d}, i32 0, i32 1\n", .{ len_gep, usize_t, dst_ssa });
            try emitter.appendFmt("  store {s} %{d}, ptr %gep.{d}\n", .{ usize_t, len_ssa, len_gep });
        },

        .slice_elem_ptr => |op| {
            const usize_t = emitter.target.ptrLLVMType();
            const data_ssa = ssa_map.get(op.data_ptr);
            const index_ssa = ssa_map.get(op.index);
            const dst_ssa = ssa_map.allocFor(op.dst);
            try emitter.appendFmt("  %{d} = getelementptr inbounds {s}, ptr %{d}, {s} %{d}\n", .{ dst_ssa, op.elem_llvm_type, data_ssa, usize_t, index_ssa });
        },

        .ptr_offset => |op| {
            const base_ssa = ssa_map.get(op.base);
            const count_ssa = ssa_map.get(op.count);
            const pt = emitter.target.ptrLLVMType();
            if (op.stride == 1) {
                if (op.is_sub) {
                    const neg_ssa = ssa_map.next_ssa;
                    ssa_map.next_ssa += 1;
                    try emitter.appendFmt("  %{d} = sub {s} 0, %{d}\n", .{ neg_ssa, pt, count_ssa });
                    const dst_ssa = ssa_map.allocFor(op.dst);
                    try emitter.appendFmt("  %{d} = getelementptr i8, ptr %{d}, {s} %{d}\n", .{ dst_ssa, base_ssa, pt, neg_ssa });
                } else {
                    const dst_ssa = ssa_map.allocFor(op.dst);
                    try emitter.appendFmt("  %{d} = getelementptr i8, ptr %{d}, {s} %{d}\n", .{ dst_ssa, base_ssa, pt, count_ssa });
                }
            } else {
                // extend count to ptr width (if needed), multiply by stride, then GEP
                const count_at_ptr_width = blk: {
                    // If count vreg was produced by a ptr-width operation, it's already i64 on 64-bit.
                    // Use the ptr type width for the multiply; bitcast/trunc/ext as needed.
                    // For safety, always emit a sext from the count type. However, sext from
                    // iN to iN is a no-op that LLVM rejects. So just use the count directly
                    // when we're already at ptr width.
                    const ext_ssa = ssa_map.next_ssa;
                    ssa_map.next_ssa += 1;
                    if (std.mem.eql(u8, pt, "i64")) {
                        // count is already ptr-width; use identity add
                        try emitter.appendFmt("  %{d} = add {s} %{d}, 0\n", .{ ext_ssa, pt, count_ssa });
                    } else {
                        try emitter.appendFmt("  %{d} = sext i32 %{d} to {s}\n", .{ ext_ssa, count_ssa, pt });
                    }
                    break :blk ext_ssa;
                };
                const scaled_ssa = ssa_map.next_ssa;
                ssa_map.next_ssa += 1;
                try emitter.appendFmt("  %{d} = mul {s} %{d}, {d}\n", .{ scaled_ssa, pt, count_at_ptr_width, op.stride });
                if (op.is_sub) {
                    const neg_ssa = ssa_map.next_ssa;
                    ssa_map.next_ssa += 1;
                    try emitter.appendFmt("  %{d} = sub {s} 0, %{d}\n", .{ neg_ssa, pt, scaled_ssa });
                    const dst_ssa = ssa_map.allocFor(op.dst);
                    try emitter.appendFmt("  %{d} = getelementptr i8, ptr %{d}, {s} %{d}\n", .{ dst_ssa, base_ssa, pt, neg_ssa });
                } else {
                    const dst_ssa = ssa_map.allocFor(op.dst);
                    try emitter.appendFmt("  %{d} = getelementptr i8, ptr %{d}, {s} %{d}\n", .{ dst_ssa, base_ssa, pt, scaled_ssa });
                }
            }
        },
    }
}

fn ccAttr(cc: CallingConvention) []const u8 {
    return switch (cc) {
        .c => "",
        .honey => "fastcc ",
        else => "",
    };
}

fn widthToLLVMType(width: Width) []const u8 {
    return switch (width) {
        .w8 => "i8",
        .w16 => "i16",
        .w32 => "i32",
        .w64 => "i64",
        .ptr => "ptr",
        .wf16 => "half",
        .wf32 => "float",
        .wf64 => "double",
    };
}

/// Map a TypeId to an LLVM type string (for struct field types in type definitions).
fn typeIdToLLVMType(type_id: TypeId, target: Target) []const u8 {
    return switch (type_id) {
        .primitive => |p| switch (p) {
            .void => "void",
            .bool => "i1",
            .u8, .i8 => "i8",
            .u16, .i16 => "i16",
            .f16 => "half",
            .u32, .i32 => "i32",
            .f32 => "float",
            .u64, .i64 => "i64",
            .usize => target.ptrLLVMType(),
            .f64 => "double",
        },
        .struct_type => "ptr", // nested struct fields are pointers
        .pointer => "ptr",
        .unresolved => "i32",
        .function => "ptr",
        .namespace => "void", // namespaces have no runtime representation
        .array => "ptr", // arrays are stack-allocated, passed as pointers
        .slice => "ptr", // slices are fat pointers { ptr, i64 }, passed as pointers
        .@"opaque" => "ptr", // opaque types only used through pointers
    };
}

/// Resolve the LLVM type string for an array element.
/// Structs are stored inline (e.g. %Point), not as pointers.
fn arrayElemLLVMType(buf: *[64]u8, element_type: TypeId, types: *const TypeRegistry, target: Target) []const u8 {
    if (element_type == .struct_type) {
        const st = types.struct_types.items[element_type.struct_type];
        const len = std.fmt.bufPrint(buf, "%{s}", .{st.name}) catch return "ptr";
        return len;
    }
    return typeIdToLLVMType(element_type, target);
}

fn isFloatType(type_id: TypeId) bool {
    if (type_id != .primitive) return false;
    return switch (type_id.primitive) {
        .f16, .f32, .f64 => true,
        else => false,
    };
}

fn binOpToLLVM(op: BinOp) []const u8 {
    return switch (op) {
        .add => "add",
        .sub => "sub",
        .mul => "mul",
        .div_s => "sdiv",
        .div_u => "udiv",
        .mod_s => "srem",
        .mod_u => "urem",
        .bit_and => "and",
        .bit_or => "or",
        .bit_xor => "xor",
        .shl => "shl",
        .shr_s => "ashr",
        .shr_u => "lshr",
    };
}

fn cmpOpToLLVM(op: CmpOp) []const u8 {
    return switch (op) {
        .eq => "eq",
        .ne => "ne",
        .lt_s => "slt",
        .lt_u => "ult",
        .le_s => "sle",
        .le_u => "ule",
        .gt_s => "sgt",
        .gt_u => "ugt",
        .ge_s => "sge",
        .ge_u => "uge",
    };
}

fn floatBinOpToLLVM(op: BinOp) []const u8 {
    return switch (op) {
        .add => "fadd",
        .sub => "fsub",
        .mul => "fmul",
        .div_s, .div_u => "fdiv",
        .mod_s, .mod_u => "frem",
        else => "fadd", // fallback for bitwise ops (shouldn't occur on floats)
    };
}

fn floatCmpOpToLLVM(op: CmpOp) []const u8 {
    return switch (op) {
        .eq => "oeq",
        .ne => "une",
        .lt_s, .lt_u => "olt",
        .le_s, .le_u => "ole",
        .gt_s, .gt_u => "ogt",
        .ge_s, .ge_u => "oge",
    };
}

/// Determine how a C ABI struct parameter should be passed based on size and target.
const StructPassing = enum {
    /// Coerce to a single integer register
    register,
    /// Split across two i64 registers (9-16 byte structs)
    two_registers,
    /// Pass by pointer (byval) for large structs
    indirect,
};

fn structParamABI(size: u32, arch: codegen.Arch) StructPassing {
    return switch (arch) {
        .aarch64 => {
            if (size <= 8) return .register;
            if (size <= 16) return .two_registers;
            return .indirect;
        },
        .x86_64 => {
            if (size <= 8) return .register;
            if (size <= 16) return .two_registers;
            return .indirect;
        },
        .arm, .x86 => .indirect,
    };
}

fn structCoercionType(size: u32, arch: codegen.Arch) []const u8 {
    return switch (arch) {
        .aarch64 => switch (size) {
            1 => "i8",
            2 => "i16",
            3, 4 => "i32",
            else => "i64",
        },
        .x86_64 => switch (size) {
            1 => "i8",
            2 => "i16",
            3, 4 => "i32",
            else => "i64",
        },
        else => "i32",
    };
}

/// Map virtual registers to LLVM SSA names.
const SsaMap = struct {
    map: [256]u16 = [_]u16{0} ** 256,
    next_ssa: u16 = 0,

    fn allocFor(self: *SsaMap, vreg: VReg) u16 {
        const ssa = self.next_ssa;
        self.next_ssa += 1;
        if (vreg < 256) {
            self.map[vreg] = ssa;
        }
        return ssa;
    }

    fn get(self: *const SsaMap, vreg: VReg) u16 {
        if (vreg < 256) {
            return self.map[vreg];
        }
        return 0;
    }
};

/// Map fp-relative offsets to alloca identifiers.
/// Tracks which allocas have been emitted to avoid duplicates.
const AllocaMap = struct {
    offsets: [64]i16 = [_]i16{0} ** 64,
    emitted: [64]bool = [_]bool{false} ** 64,
    count: u16 = 0,

    fn getOrCreate(self: *AllocaMap, offset: i16) u16 {
        // check if offset already mapped
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) return @intCast(i);
        }
        // new offset
        const id = self.count;
        self.offsets[id] = offset;
        self.count += 1;
        return id;
    }

    fn isEmitted(self: *const AllocaMap, offset: i16) bool {
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) return self.emitted[i];
        }
        return false;
    }

    fn markEmitted(self: *AllocaMap, offset: i16) void {
        for (self.offsets[0..self.count], 0..) |off, i| {
            if (off == offset) {
                self.emitted[i] = true;
                return;
            }
        }
    }
};

/// LLVM IR text emitter.
const Emitter = struct {
    allocator: mem.Allocator,
    buffer: std.ArrayList(u8),
    target: Target,

    fn init(allocator: mem.Allocator, target: Target) !Emitter {
        return .{
            .allocator = allocator,
            .buffer = try std.ArrayList(u8).initCapacity(allocator, 4096),
            .target = target,
        };
    }

    fn deinit(self: *Emitter) void {
        self.buffer.deinit(self.allocator);
    }

    fn getOutput(self: *const Emitter) []const u8 {
        return self.buffer.items;
    }

    fn raw(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn comment(self: *Emitter, msg: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, "; ");
        try self.buffer.appendSlice(self.allocator, msg);
        try self.buffer.append(self.allocator, '\n');
    }

    fn newline(self: *Emitter) !void {
        try self.buffer.append(self.allocator, '\n');
    }

    fn appendSlice(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn appendFmt(self: *Emitter, comptime fmt: []const u8, args: anytype) !void {
        var buf: [512]u8 = undefined;
        const text = std.fmt.bufPrint(&buf, fmt, args) catch return error.OutOfMemory;
        try self.buffer.appendSlice(self.allocator, text);
    }
};
