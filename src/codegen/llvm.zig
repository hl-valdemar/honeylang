const std = @import("std");
const mem = std.mem;

const mir = @import("mir.zig");
const MIRModule = mir.MIRModule;
const MIRFunction = mir.MIRFunction;
const MInst = mir.MInst;
const VReg = mir.VReg;
const Width = mir.Width;
const BinOp = mir.BinOp;
const CmpOp = mir.CmpOp;

const codegen = @import("codegen.zig");
const Target = codegen.Target;
const Arch = codegen.Arch;
const Os = codegen.Os;

const CallingConvention = @import("../parser/ast.zig").CallingConvention;

/// Lower MIR module to LLVM IR text format.
pub fn lower(allocator: mem.Allocator, module: *const MIRModule, target: Target) ![]const u8 {
    var emitter = try Emitter.init(allocator, target);
    defer emitter.deinit();

    // module header
    try emitter.comment("Generated by the Honey compiler");
    try emitter.raw("source_filename = \"honey\"");
    try emitter.appendFmt("target triple = \"{s}\"\n", .{emitter.getTargetTriple()});
    try emitter.newline();

    // lower each function
    for (module.functions.items) |*func| {
        try lowerFunction(&emitter, func);
    }

    return try allocator.dupe(u8, emitter.getOutput());
}

fn lowerFunction(emitter: *Emitter, func: *const MIRFunction) !void {
    // determine calling convention attribute
    const cc_attr = switch (func.call_conv) {
        .c => "",
        .honey => "fastcc ",
        else => "",
    };

    // function signature - for now assume i32 return type
    try emitter.appendFmt("define {s}i32 @{s}() {{\n", .{ cc_attr, func.name });
    try emitter.raw("entry:");

    // track SSA values: vreg -> LLVM SSA name
    var ssa_map = SsaMap{};

    for (func.instructions.items) |inst| {
        try lowerInst(emitter, inst, &ssa_map);
    }

    try emitter.raw("}");
    try emitter.newline();
}

fn lowerInst(emitter: *Emitter, inst: MInst, ssa_map: *SsaMap) !void {
    switch (inst) {
        .mov_imm => |op| {
            // In LLVM IR, we just track the constant value - we'll inline it at use sites
            // But for simplicity, we emit an add with 0 to materialize the value
            const ssa_name = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  %{d} = add {s} 0, {d}\n", .{ ssa_name, type_str, op.value });
        },

        .mov_reg => |op| {
            // Copy is just an add with 0 in LLVM IR SSA
            const src_ssa = ssa_map.get(op.src);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            try emitter.appendFmt("  %{d} = add {s} %{d}, 0\n", .{ dst_ssa, type_str, src_ssa });
        },

        .binop => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const op_str = binOpToLLVM(op.op);

            try emitter.appendFmt("  %{d} = {s} {s} %{d}, %{d}\n", .{
                dst_ssa,
                op_str,
                type_str,
                lhs_ssa,
                rhs_ssa,
            });
        },

        .cmp => |op| {
            const lhs_ssa = ssa_map.get(op.lhs);
            const rhs_ssa = ssa_map.get(op.rhs);
            const dst_ssa = ssa_map.allocFor(op.dst);
            const type_str = widthToLLVMType(op.width);
            const cmp_op_str = cmpOpToLLVM(op.op);

            // icmp returns i1, we need to extend to the width
            try emitter.appendFmt("  %cmp{d} = icmp {s} {s} %{d}, %{d}\n", .{
                dst_ssa,
                cmp_op_str,
                type_str,
                lhs_ssa,
                rhs_ssa,
            });
            try emitter.appendFmt("  %{d} = zext i1 %cmp{d} to {s}\n", .{
                dst_ssa,
                dst_ssa,
                type_str,
            });
        },

        .ret => |op| {
            if (op.value) |vreg| {
                const src_ssa = ssa_map.get(vreg);
                const type_str = widthToLLVMType(op.width);
                try emitter.appendFmt("  ret {s} %{d}\n", .{ type_str, src_ssa });
            } else {
                // No explicit value - return 0 for integer types (implicit return)
                const type_str = widthToLLVMType(op.width);
                try emitter.appendFmt("  ret {s} 0\n", .{type_str});
            }
        },

        .prologue, .epilogue => {
            // LLVM handles prologue/epilogue automatically
        },
    }
}

fn widthToLLVMType(width: Width) []const u8 {
    return switch (width) {
        .w32 => "i32",
        .w64 => "i64",
    };
}

fn binOpToLLVM(op: BinOp) []const u8 {
    return switch (op) {
        .add => "add",
        .sub => "sub",
        .mul => "mul",
        .div_s => "sdiv",
        .div_u => "udiv",
        .mod_s => "srem",
        .mod_u => "urem",
        .bit_and => "and",
        .bit_or => "or",
        .bit_xor => "xor",
        .shl => "shl",
        .shr_s => "ashr",
        .shr_u => "lshr",
    };
}

fn cmpOpToLLVM(op: CmpOp) []const u8 {
    return switch (op) {
        .eq => "eq",
        .ne => "ne",
        .lt_s => "slt",
        .lt_u => "ult",
        .le_s => "sle",
        .le_u => "ule",
        .gt_s => "sgt",
        .gt_u => "ugt",
        .ge_s => "sge",
        .ge_u => "uge",
    };
}

/// Map virtual registers to LLVM SSA names.
const SsaMap = struct {
    map: [256]u16 = [_]u16{0} ** 256,
    next_ssa: u16 = 0,

    fn allocFor(self: *SsaMap, vreg: VReg) u16 {
        const ssa = self.next_ssa;
        self.next_ssa += 1;
        if (vreg < 256) {
            self.map[vreg] = ssa;
        }
        return ssa;
    }

    fn get(self: *const SsaMap, vreg: VReg) u16 {
        if (vreg < 256) {
            return self.map[vreg];
        }
        return 0;
    }
};

/// LLVM IR text emitter.
const Emitter = struct {
    allocator: mem.Allocator,
    buffer: std.ArrayList(u8),
    target: Target,

    fn init(allocator: mem.Allocator, target: Target) !Emitter {
        return .{
            .allocator = allocator,
            .buffer = try std.ArrayList(u8).initCapacity(allocator, 4096),
            .target = target,
        };
    }

    fn deinit(self: *Emitter) void {
        self.buffer.deinit(self.allocator);
    }

    fn getOutput(self: *const Emitter) []const u8 {
        return self.buffer.items;
    }

    fn getTargetTriple(self: *const Emitter) []const u8 {
        return self.target.getLLVMTriple();
    }

    fn raw(self: *Emitter, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn comment(self: *Emitter, msg: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, "; ");
        try self.buffer.appendSlice(self.allocator, msg);
        try self.buffer.append(self.allocator, '\n');
    }

    fn newline(self: *Emitter) !void {
        try self.buffer.append(self.allocator, '\n');
    }

    fn appendFmt(self: *Emitter, comptime fmt: []const u8, args: anytype) !void {
        var buf: [512]u8 = undefined;
        const text = std.fmt.bufPrint(&buf, fmt, args) catch return error.OutOfMemory;
        try self.buffer.appendSlice(self.allocator, text);
    }
};
